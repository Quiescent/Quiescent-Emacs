#+TITLE:     Emacs Startup & Configuration
#+AUTHOR:    Edward John Steere
#+EMAIL:     edward dot steere at gmail dot com
#+LANGUAGE:  en
#+STARTUP: showall

* Introduction
This is the story of my Emacs configuration.  It's as much a story of
how I learned to program as it is a setup for Emacs -- the timeless
editor.

In this document you can expect to find:
 - how I configure Emacs;
 - the story of how I came to use particular parts of Emacs;
 - links to other Emacs Lisp sources where I've defined features to
   extend Emacs and the packages which I use;

The document begins by outlining the way in which it is expected to be
used.  Following this I detail the modifications I've made to it in
order to support he various environments on which I run it.  It then
details modifications which I've made to all programming modes.
Alterations and additions to specific modes follow this.  It then
moves into usages which don't relate to programming at all.  Another
section details modifications made to the appearance of Emacs.

The document concludes with some fluffy text about my configuration
and what I hope to achieve with it in the future.

* A Note on the Literate Nature of this Document
This document is literate and interactive.  It is, of course, best
viewed in Emacs itself.  Not only because it'll mark up all of the
code and headings correctly, but also because it'll provide
interactive development features.  You can edit the document and the
code contained directly, but it is recommended that you instead enter
code blocks with the =C-<single-quote>= binding.  Repeating that
binding will return you to the document proper.  While in this mode
you can execute the code as one usually would.

While not editing a source code block using the =C-<single-quote>=
binding you can still execute the code block to alter the Lisp
environment.  This is done with the binding =C-c C-c=.

* Modifications to Support the Environment
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref modifications-to-support-the-environment :exports none
  <<exec-path-from-shell>>
  <<toggle-proxy>>
  <<change-keyboard-layouts>>
  <<system-specific-tasks>>
  <<system-specific-config>>
#+END_SRC

This section details the modifications which I've made to Emacs in
order to support the different environments which I run it on.

I use a set of configurations which are specific to each machine which
I run Emacs on in order to optimise my work flows on each system.
This allows me to program quick tasks which help automate laborious
tasks on those machines and to integrate more tightly with each tool
set that I use.  I load the configurations and tasks outside of this
file and I don't committing those files to my Emacs configuration
repository.  In doing so the configuration can vary per platform.

There are also modifications which are the same for the same type of
platform.  i.e. I'll always have the =PATH= variable determined from
=bash= on Mac OS X.

** OS X
On OS X there's a very irritating interaction between Emacs and the
system path.  For some reason GUI applications aren't launched with
the same path as terminal applications.  In order to fix this you can
use a package (ofc!) which sets the =exec-path= (what Emacs considers
to be the path) in an Emacs session to the same value as it would be
in Bash.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref exec-path-from-shell :lexical t
  (use-package exec-path-from-shell
    :straight t
    :init
    (when (not (or (equal system-type 'windows-nt)
                   (equal system-type 'gnu/linux)))
      (with-eval-after-load "exec-path-from-shell"
        (exec-path-from-shell-initialize))))
#+END_SRC

** Controlling the Proxy
Sometimes I need control over environment variables so that I can
control third party binaries which Emacs plugs into.  Configuring the
proxy and whether it's on or off is the first reason that I've needed
this feature.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref toggle-proxy :lexical t
  (defvar quiescent-http-proxy ""
    "The previous/current value of the http proxy variable.")

  (defvar quiescent-http-proxy-active ""
    "Whether the proxy ought to be active right now.")

  (defun quiescent-toggle-proxy ()
    "Remember the proxy and then toggle it on and off when called."
    (interactive)
    (when (and (not (boundp 'queiescent-http-proxy))
               (not (string-equal quiescent-http-proxy "")))
      (progn
        (message "First binding")
        (setq quiescent-http-proxy        (getenv "HTTP_PROXY"))
        (setq quiescent-http-proxy-active t)))
    (if quiescent-http-proxy-active
        (progn
          (message "Unsetting proxy")
          (setenv "HTTP_PROXY" "")
          (setq quiescent-http-proxy-active nil))
        (progn
          (message "Setting proxy")
          (setenv "HTTP_PROXY" quiescent-http-proxy)
          (setq quiescent-http-proxy-active t))))
#+END_SRC

** Changing the Keyboard Layout
I pair a lot at work and I need to be able to switch layouts when
Emacs is running as the window manager.  I've created a function to
switch layouts quickly.  The function makes use of the =setxkbmap=
command.  Usually I use =setxkbmap -layout "dvorak" -option
ctrl:nocaps= in my =.xinitrc= to make dvorak the layout when I boot
in.  A small modification is needed to be able to toggle between
layouts.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref change-keyboard-layouts :lexical t
  (defun quiescent-toggle-keyboard-layout ()
    "Toggle between US and Dvorak keyboard layouts."
    (interactive)
    (set-process-filter (start-process "*Check-Layout*"
                                       nil
                                       "setxkbmap"
                                       "-query")
                        #'quiescent-handle-keyboard-query))

  (defun quiescent-handle-keyboard-query (_ output)
    "Use the output to decide whether to change to QWERTY or Dvorak."
    (if (string-match-p "dvorak" output)
        (quiescent-switch-to-layout "us")
      (quiescent-switch-to-layout "dvorak")))

  (defun quiescent-switch-to-layout (layout)
    "Use setkbmap to change the keyboard layout to LAYOUT."
    (start-process "*Change-Layouts*"
                   nil
                   "setxkbmap" "-layout" layout "-option" "ctrl:nocaps"))
#+END_SRC

** Windows Bindings
The super key used to be a thing on old computers, especially those of
a "lispy" nature.  It's really handy because it lets you bind shorter
key bindings by using it the same way you would meta or control.  To
use it on Windows you need to tell Emacs to bypass Windows' usual
bindings.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref windows-super-key :lexical t
  (if running-windows
    (progn (setq w32-pass-lwindow-to-system nil)
           (setq w32-lwindow-modifier 'super)
           (message "System is running windows"))
    (message "System is *NIX :)"))
#+END_SRC

** System Specific Tasks
I like to define tasks which optimise my work flow on each computer I
use.  By their nature these tasks couple tightly with the machine on
which they're run, therefore they wont usually work across machines.
I store these commands in a folder [[~/.emacs.d/system-specific-tasks/system-specific-tasks.el][inside my EMACS directory.]]

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref system-specific-tasks :lexical t
  (let ((system-specific-tasks-file "~/.emacs.d/system-specific-tasks/system-specific-tasks.el"))
    (when (file-exists-p system-specific-tasks-file)
      (load-file system-specific-tasks-file)))
#+END_SRC

** System Specific Config
I've put system specific settings in their own folder, including mail
settings and variables which I use throughout my setup to determine
whether I'm running a particular OS (mostly just for windows) and
where emacs should start.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref system-specific-config :lexical t
  (use-package system-vars
    :load-path "~/.emacs.d/conf")

  (defconst mail-settings-path "~/.emacs.d/conf/mail-settings.el"
    "The path to my mail settings")

  (when (file-exists-p mail-settings-path)
    (load-file mail-settings-path))
#+END_SRC

* Programming Modifications Across the Board
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref programming-modifications-across-the-board :exports none
  <<no-tabs>>
  <<column-number-mode>>
  <<disabled-commands>>
  <<other-window>>
  <<buffer-set-operations>>
  <<tiny-mode>>
  <<hippie-expand>>
  <<avy>>
  <<mark-and-pop>>
  <<ensure-pop-moves>>
  <<visual-marks>>
  <<auto-highlight-symbol>>
  <<hydra>>
  <<window-jump>>
  <<isearch-kill>>
  <<isearch-first-last-hit>>
  <<iy-mods>>
  <<quiescent-cross-link>>
  <<multiple-cursors>>
  <<iedit>>
  <<hiscroll>>
  <<general-recursive-session>>
  <<composable>>
  <<eacl>>
  <<completion>>
  <<matt-is-watching>>
  ;; <<realgud>>
  <<clean-file>>
  <<compile>>
  <<flycheck>>
  <<flymake>>
  <<hide-show>>
  <<paren>>
  <<yasnippet>>
  <<company-or-yas-on-tab>>
  <<skeletons>>
  <<paredit>>
  <<electric-pair>>
  <<electric-pair-ignore-comments>>
  <<electric-layout>>
  <<save-place>>
  <<emacs-refactor>>
  <<temp-view>>
  <<compilation-regexps>>
  <<random-data-here>>
  <<editor-config>>
  <<eval-on-save>>
  <<too-long-lines>>
  <<ediff-accept-both>>
  <<helm>>
  <<shells-setup>>
  <<shell-here>>
  <<unique-shell>>
  <<compilation-minor-mode-key>>
  <<eshell-setup>>
  <<eshell-compilation-minor-mode>>
  <<eshell-company-autosuggest>>
  <<eshell-company-autosuggest-fix-candidates>>
  <<project-find-file>>
  <<project-find-file-other-window>>
  <<project-settings>>
  <<etags-tag-search>>
  <<project-command-at-interval>>
  <<goto-chg>>
  <<vc-git-grep>>
  <<idutils>>
  <<backup-files>>
  <<gtags>>
  <<smartscan>>
  <<wgrep>>
  <<read-only>>
  <<go-up>>
  <<increment-number-at-point>>
  <<recentf>>
  <<ignore-regex-case>>
  <<keyboard-macros>>
  <<string-replacement>>
  <<aligned-navigation>>
  ;;<<semantic>>
  <<separedit>>
  <<thought-stack>>
  <<dumb-jump>>
  <<variable-translations>>
#+END_SRC
In this section I'll detail the modes and modifications to programming
in Emacs which don't pertain to any single language and instead modify
the entire environment.  These modifications aren't listed in any
particular order and they include modifications to navigation and
similar commands which change the way that I move around my system
while programming.

Many people swear by their IDE/Editors capability to complete what
they were typing.  Usually this involves the use of some kind of drop
down box.  I find that these tools add robustness, but actually slow
your typing down, because you have to wait for the list to appear,
read it, and then select the option you wanted.

Aside from encouraging one not to learn what functions /actually do/
before using them, this also slows down your editing.  I've adopted
tools which instead allow me to quickly enter what I need to -- which
first requires that I know /what I should be entering/.

It's no use keeping your hands in the correct typing positions the
whole time if it takes an age to move the point to areas of the
screen.  If it takes ages to move about then you may as well take the
performance hit of using a mouse.  Well EMACS has some power tools
which help you move to just about any visible point in at most about
four key strokes and non visible points in a small (but not
predictable) amount of time.

The following two packages are about super fast navigation of the
point to visible portions of the screen.

** No Tab Characters in Code!
There's no guarantee on the way that tabs render in different editors,
when printed or when viewed on the Internet.  Spaces don't suffer from
this problem.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref no-tabs :lexical t
  (setq-default indent-tabs-mode nil)
  (setq tab-width 4)
#+END_SRC

** Column Numbers
When I got going with C++ I was taught via the command line.  One of
the things which compilers reported to you back then and today and so
has become very important is which column an error occurs
on.  Confusingly, EMACS doesn't show column numbers by default.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref column-number-mode :lexical t
  (column-number-mode 1)
#+END_SRC

** Disabled Commands
Up and down casing a region is disabled by default (!?) This wont do!

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref disabled-commands :lexical t
  (put 'upcase-region   'disabled nil)
  (put 'downcase-region 'disabled nil)
#+END_SRC

** Manipulating the Other Window
It's often useful to modify the other window without ever leaving this
window.  The following library contains, to begin with, functions for
moving the point about in the other window.  I'm thinking that this
library will end up being pretty big after a while.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref other-window :lexical t
  (defmacro quiescent-in-other-buffer (&rest body)
    "Execute BODY in the other window and return to the startindg window."
    `(progn
       (other-window 1)
       ,@body
       (select-window (previous-window))))

  (defun quiescent-other-window-line-down ()
    "Move point one line down in the other window.

  Maintains the point in the current window."
    (interactive)
    (quiescent-in-other-buffer
     (forward-line)))

  (defun quiescent-other-window-line-up ()
    "Move point one line up in the other window.

  Maintains the point in the current window."
    (interactive)
    (quiescent-in-other-buffer
     (forward-line -1)))

  (defun quiescent-search-other-window ()
    "Search the other window and then pop back to the current one."
    (interactive)
    (progn
      (quiescent-in-other-buffer
       (isearch-forward))))
#+END_SRC

** Buffer Set Operations
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref buffer-set-operations :exports none :lexical t
  <<buffer-disjunction>>
  <<this-but-not-that>>
#+END_SRC
This is a section where I'm creating set like operations to work on
buffers.  The first one that I needed was disjunction -- to solve the
problem of which lines are not common to each buffer.  I needed to
check whether I had deleted files while restructuring a project.  Git
would have been able to tell me except that it definitely got confused
by some of the changes and didn't recognise them as moves/renames.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref buffer-disjunction :lexical t
  (defvar *buffer-disjunction-results-buffer-name* "*disjunction-results*"
    "The name of the buffer to display disjunction results in.")

  (require 'cl-lib)

  (defun buffer-disjunction-lines-from-buffer (buffer)
    "Produce the lines in BUFFER as a list of strings."
    (with-current-buffer buffer
      (split-string (buffer-substring (point-min) (point-max))
                    "\n"
                    " ")))

  (defun buffer-disjunction-buffer-disjunction (this-buffer that-buffer)
    "Produce lines which are not in both THIS-BUFFER and THAT-BUFFER.

    Results are displayed in a new buffer controlled by
    `*buffer-disjunction-results-buffer-name*'."
    (interactive "bThis buffer: \nbThat buffer:")
    (let* ((these-lines    (buffer-disjunction-lines-from-buffer this-buffer))
           (those-lines    (buffer-disjunction-lines-from-buffer that-buffer))
           (results-buffer (get-buffer *buffer-disjunction-results-buffer-name*))
           (diff           (mapcar (lambda (x) (concat x "\n"))
                                   (cl-set-difference these-lines those-lines))))
      (switch-to-buffer (if (not (bufferp results-buffer))
                            (generate-new-buffer *buffer-disjunction-results-buffer-name*)
                            results-buffer))
      (erase-buffer)
      (mapc #'insert diff)))
#+END_SRC

Shortly after writing this I realised that I actually needed an
operation which is "all the lines which are in this buffer and not
that buffer."

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref this-but-not-that :lexical t
  (defvar *buffer-set-difference-results-buffer-name* "*this-but-not-that-results*"
    "The name of the buffer to display this-but-not-that results in.")

  (defun buffer-set-difference (this-buffer that-buffer)
    "Produce lines which are in THIS-BUFFER but not THAT-BUFFER.

    Results are displayed in a new buffer controlled by
      `*buffer-set-difference-results-buffer-name*'."
    (interactive "bThis buffer: \nbThat buffer:")
    (let* ((these-lines    (buffer-disjunction-lines-from-buffer this-buffer))
           (those-lines    (mapcar (lambda (x) (cons x t))
                                   (buffer-disjunction-lines-from-buffer that-buffer)))
           (results-buffer (get-buffer *buffer-set-difference-results-buffer-name*))
           (diff           (mapcar (lambda (x) (concat x "\n"))
                                   (cl-remove-if (lambda (x) (assoc x those-lines))
                                                 these-lines))))
      (switch-to-buffer (if (not (bufferp results-buffer))
                            (generate-new-buffer *buffer-set-difference-results-buffer-name*)
                          results-buffer))
      (erase-buffer)
      (mapc #'insert diff)))
#+END_SRC

** Tiny Mode
Ever been coding and just wished that you could type a formatted
sequence of symbols quickly?  Tiny does this in a minimal amount of
keystrokes by expanding a super brief syntax for formatted sequences.

Tiny is a package by the excellent eLisp hacker abo-abo.  It allows one
to create formatted sequences with a very concise syntax.  See [[https://github.com/abo-abo/tiny][this
documentation]] for more.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref tiny-mode :lexical t
  (use-package tiny
      :straight t
      :config (tiny-setup-default))
#+END_SRC

** Hippie Expand
Emacs comes with a fast auto-guess-expansion system which expands the
word prior to point.  Hippie expand is an extension of this mode which
provides a more sophisticated interface and can complete entire code
blocks.  I just replace the default package (dabbrev) with Hippie
Expand to use this feature.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref hippie-expand :lexical t
  (global-set-key [remap dabbrev-expand] 'hippie-expand)
#+END_SRC

** Avy
Avy is a system designed to make it fast and easy to jump to any point
you can see in Emacs.  It does so by prompting for a character and then
highlighting each visible occurrence with a letter or a sequence of
letters by completing the sequence of letters for the point you want
to jump to your point will move there.  I've bound the avy command I
use all the time to =s-.=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref avy :lexical t
  (use-package avy
    :straight t
    :config (progn
              (setq avy-timeout-seconds 0.1)
              (global-set-key (kbd "s-x") #'quiescent-avy-super-jump)
              (global-set-key (kbd "s-.") #'avy-goto-word-or-subword-1)
              (global-set-key (kbd "s-c") #'quiescent-avy-copy-symbol)
              (global-set-key (kbd "s-C") #'quiescent-avy-copy-sexp)))

  (defun quiescent-avy-super-jump ()
    "Jump to a point with avy and then find the definition."
    (interactive)
    (progn
      (avy-goto-word-or-subword-1)
      (xref-find-definitions (thing-at-point 'symbol))))

  (defun quiescent-avy-copy-symbol ()
    "Copy a word subword or symbol using avy."
    (interactive)
    (save-excursion
      (save-window-excursion
        (avy-goto-word-or-subword-1)
        (mark-sexp)
        (kill-ring-save (region-beginning) (region-end))))
    (yank))

  (defun quiescent-avy-copy-sexp ()
    "Copy an sexp using avy.
  Goes backward up list and then copies the sexp."
    (interactive)
    (save-excursion
      (save-window-excursion
        (avy-goto-word-or-subword-1)
        (backward-up-list)
        (mark-sexp)
        (kill-ring-save (region-beginning) (region-end))))
    (yank))

  (defun quiescent-goto-char (&optional str)
    "Perform an isearch-like session with STR.
  If candidates are numbered as you go and if you type the number
  of a candidate then you can jump to it."
    (interactive)
    (let ((char (read-string (concat "search: " (or str "")))))
      (if (member (aref char 0) '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
          (quiescent-jump-to-candidate char str)
        (let ((search-string (concat str char)))
          (quiescent-highlight-matches search-string)
          (call-interactively (quiescent-goto-char search-string))))))


  (define-key isearch-mode-map (kbd "C-'") 'avy-isearch)
#+END_SRC

** Marking and Popping
Marking and popping is the built in mechanism for moving about buffers
to places that you've been and did some kind of move from.  I don't
think that enough of the large movement commands set the mark so to
begin with these settings will make that different.

The first thing that I'm changing here is up-list.  When operating on
a large list or an XML document moves the point a huge distance.  So
the idea is to just make sure that the mark is set when doing going up
list so that I can get back to where I was.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref mark-and-pop :lexical t
  (defun quiescent-push-mark-to-ring (&optional arg escape-string no-syntax-crossing)
    "Double `push-mark' for pushing straight onto the ring.
  Ignore ARG, ESCAPE-STRING and NO-SYNTAX-CROSSING, they're there
  to make the advice work."
    (ignore arg)
    (ignore escape-string)
    (ignore no-syntax-crossing)
    (progn
      (push-mark nil t)
      (push-mark nil t)))

  (defun quiescent-backward-up-list ()
    "Go `backward-up-list' leaving behind the marker."
    (interactive)
    (progn
      (quiescent-push-mark-to-ring)
      (call-interactively #'backward-up-list)))

  (global-set-key (kbd "C-M-u") #'quiescent-backward-up-list)

  (with-eval-after-load "paredit"
    (define-key paredit-mode-map (kbd "C-M-u") #'quiescent-backward-up-list))

  (advice-add #'nxml-backward-up-element :before
              #'quiescent-push-mark-to-ring)
#+END_SRC

I've found that sometimes popping the mark ring can result in the
point staying where it is.  The same can sometimes be true of popping
the xref ring.  I'd like both of those commands to ensure that the
point ends up moving.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref ensure-pop-moves :lexical t
  (defun quiescent-keep-popping-til-moved (pop-function &rest args)
    "Keep popping the mark until either the mark ring is empty or the point moved."
    (interactive)
    (progn
      (while (and mark-ring
                  (= (point) (marker-position (car mark-ring))))
        (pop mark-ring))
      (apply pop-function args)))

  (advice-add #'pop-to-mark-command :around #'quiescent-keep-popping-til-moved)
#+END_SRC

I've recently discovered that transient mark mode wasn't always the
way that the region worked.  In fact there's almost always a region
even if it's not "active."  It's the region between the mark and the
point.  I like thinking this way, but you do need to be able to see
where the last marks were.  I tried it out for a while and I think
that you lose more than you gain so I'm going back to the way it was
before but with the mark made visible, because that's still very
useful.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref visual-marks :lexical t
  (use-package visible-mark
    :straight t
    :config (progn
              (global-visible-mark-mode 1)
              (setq visible-mark-max 1)
              (setq visible-mark-faces `(visible-mark-face1 visible-mark-face2))))
#+END_SRC

** Auto Highlight Symbol Mode
Sometimes it can be useful to see the other occurrences of a symbol in
the visible buffer.  Auto Highlight Mode does this for you.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref auto-highlight-symbol :lexical t
  (use-package auto-highlight-symbol
      :straight t)
#+END_SRC

** Hydra
Hydra is an incredibly cool package which allows one to ``chop the
head off of large key bindings'' so to speak.  Some packages have long
base key bindings, e.g.  =C-c C-c C-x <x>= where =<x>= is some postfix
key to select the final action in a package whose base key binding is
=C-c C-c C-x=.  It takes ages to always hit the base binding so Hydra
would let one instead enter a Hydra (read state) at =C-c C-c C-x=
where you could hit any <x> and it would be as if you had hit the base
binding too.

Hydras are incredibly powerful and I wouldn't be able to explain all
there is here.  Check out [[https://github.com/abo-abo/hydra/wiki/Emacs][this documentation for more info]].  I've added
Hydra to [[Emacs Package Management][my package management]].

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref hydra :lexical t
  (use-package hydra
    :straight t
    :config
    (progn
      <<hydra-drawing>>
      <<code-explorer>>
      ))
#+END_SRC

*** My Own Hydras
Naturally one uses Hydra to create their own systems of chopping of
heads and heroic work saving lispery.  What follows are the ones I've
made.

**** Drawing
I also used hydra to create a simple psuedo ASCII drawing mode.  It
keeps track of the line you're on and uses the normal moving key binds
without =<Control>= to move maintaining the current column to give the
appearance of moving about on a canvas.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref hydra-drawing :lexical t
  (defhydra hydra-drawing (:color pink
                                  :pre (overwrite-mode)
                                  :post (progn (whitespace-cleanup)
                                               (overwrite-mode -1)))
    "Hydra draw"
    ("f" (hydra-drawing-forward-maintaining-line)                              "forward")
    ("b" backward-char                                                         "backward")
    ("p" (hydra-drawing-move-maintaining-column (lambda () (forward-line -1))) "previous line")
    ("n" (hydra-drawing-move-maintaining-column 'next-line)                    "next line")
    ("q" nil                                                                   "quit" :color blue))
  (global-set-key (kbd "C-c C-c d") 'hydra-drawing/body)

  (defun hydra-drawing-move-maintaining-column (move-action)
    "Execute `MOVE-ACTION' while attempting to mainting column position."
    (let* ((column-before)
           (column-after))
      (progn
        (setq column-before (current-column))
        (when (= (point) (point-max))
          (newline)
          (backward-char))
        (funcall move-action)
        (setq column-after (current-column))
        (while (< column-after column-before)
          (insert " ")
          (setq column-after (1+ column-after))))))

  (defun hydra-drawing-forward-maintaining-line ()
    "Move forward on character attempting to maintain the current line."
    (let* ((line-before (line-number-at-pos)))
      (if (= (point) (point-max))
          (insert " ")
        (progn (forward-char)
               (when (/= line-before (line-number-at-pos))
                 (progn
                   (backward-char)
                   (insert " ")))))))
#+END_SRC


**** Code Explorer
This is a hydra which I came up with a while ago and now I'm
resurrecting because previously the features which I wanted weren't
well supported by my Emacs at the time.  I now see projects like
Ensime and LSP as being able to support all of it's features going
forward.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref code-explorer :lexical t
  (defhydra hydra-explore-code (:pre (global-auto-highlight-symbol-mode t)
                                     :post (global-auto-highlight-symbol-mode -1)
                                     :color amaranth)
    "
    Code Explorer
    ^Move^                    ^Jump^               ^Project^
    ^^^^^^^^---------------------------------------------------------
    _f_: forward  s-exp       _B_: pop   mark      _s_: project grep
    _b_: backward s-exp       _m_: mark  point     _g_: goto    file
    _n_: forward  list        _j_: xref  jump
    _p_: backward list        _P_: prev  file
    _d_: down     list        _x_: super jump
    _u_: up       list        _i_: imenu

    _q_: quit
    "
    ("f" forward-sexp                     nil)
    ("b" backward-sexp                    nil)
    ("n" forward-list                     nil)
    ("p" backward-list                    nil)
    ("d" down-list                        nil)
    ("u" up-list                          nil)
    ("P" (pop-global-mark)                nil)
    ("B" (pop-to-mark-command)            nil)
    ("m" (push-mark)                      nil)
    ("j" xref-find-definitions            nil)
    ("s" quiescent-vc-git-grep            nil)
    ("x" quiescent-avy-super-jump         nil)
    ("i" quiescent-helm-semantic-or-imenu nil)
    ("q" nil                              nil)
    ("g" project-find-file                nil))
  (key-chord-define-global "qc" 'hydra-explore-code/body)

  (defun quiescent-helm-semantic-or-imenu ()
    "Do `helm-semantic-or-imenu' with arg as 0."
    (interactive)
    (call-interactively #'helm-semantic-or-imenu))
#+END_SRC

** Window Jump
Sometimes I want to just move to a window nearby, i.e.  not do a long
distance jump.  For that I'm trying out window-jump to move my point
left/right/up/down in my windows.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref window-jump :lexical t
  (use-package window-jump
    :straight t
    :init (when (and (boundp 'key-chord-mode)
                     (not key-chord-mode))
            (key-chord-mode 1)
            (bind-chord ",u" #'window-jump-up)
            (bind-chord ",d" #'window-jump-down)
            (bind-chord ",l" #'window-jump-left)
            (bind-chord ",r" #'window-jump-right)))
#+END_SRC

** iSearch
iSearch is an incredibly powerful utility which turns searching into a
fast way of moving around a buffer among other things.  I sometimes
want to kill the thing that is currently highlighted by iSearch.  The
following snippet does just that and comes from the Emacs wiki.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref isearch-kill :lexical t
  (defun quiescent-kill-isearch-match ()
    "Kill the current isearch match string and continue searching."
    (interactive)
    (kill-region isearch-other-end (point))
    (isearch-repeat-forward))

  (define-key isearch-mode-map [(control k)] 'quiescent-kill-isearch-match)
#+END_SRC

Something which I needed this morning was to move to the first hit in
the buffer.  I decided to make it general :)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref isearch-first-last-hit :lexical t
  (defun quiescent-first-search-hit ()
    "Activate isearch from the start of the buffer using the existing string if it's present."
    (interactive)
    (progn
      (let ((original-isearch-string (when isearch-mode isearch-string)))
        (goto-char (point-min))
        (isearch-forward nil t)
        (when original-isearch-string (isearch-yank-string original-isearch-string)))))

  (defun quiescent-last-search-hit ()
    "Activate isearch from the end of the buffer using the existing string if it's present."
    (interactive)
    (progn
      (let ((original-isearch-string (when isearch-mode isearch-string)))
        (goto-char (point-max))
        (isearch-backward nil t)
        (when original-isearch-string (isearch-yank-string original-isearch-string)))))

  (defun quiescent-turn-off-key-chord-mode (&rest _)
    "Turn off `key-chord-mode'."
    (key-chord-mode -1))

  (defun quiescent-turn-on-key-chord-mode (&rest _)
    "Turn on `key-chord-mode'."
    (key-chord-mode 1))

  (advice-add #'isearch-mode :before #'quiescent-turn-off-key-chord-mode)
  (advice-add #'isearch-done :after #'quiescent-turn-on-key-chord-mode)

  (define-key isearch-mode-map (kbd "M-<") #'quiescent-first-search-hit)
  (define-key isearch-mode-map (kbd "M->") #'quiescent-last-search-hit)

  (global-set-key (kbd "M-s M-<") #'quiescent-first-search-hit)
  (global-set-key (kbd "M-s M->") #'quiescent-last-search-hit)
#+END_SRC

** Iy
In multiple cursors mode I miss the ability to invoke iSearch -- one
of the most important and used packages in my Emacs.  The next best
thing is to either zap to, or move to a particular character.  This is
what Iy mode will give you, and it's not only for multiple cursors
this is just the best case I could think of.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref iy-mods :lexical t
  ;; (defun quiescent-init-iy-hydra-forward ()
  ;;   "Start using the iy hydra with iy forward."
  ;;   (interactive)
  ;;   (call-interactively 'iy-go-to-char)
  ;;   (quiescent-hydra-iy-go-to-char/body))

  ;; (defun quiescent-init-iy-hydra-backward ()
  ;;   "Start using the iy hydra with iy backward."
  ;;   (interactive)
  ;;   (call-interactively 'iy-go-to-char-backward)
  ;;   (quiescent-hydra-iy-go-to-char/body))

  ;; (use-package iy-go-to-char
  ;;  :straight t)

  ;; (global-set-key (kbd "s-d") #'quiescent-init-iy-hydra-forward)
  ;; (global-set-key (kbd "s-i") #'quiescent-init-iy-hydra-backward)

  ;; (defhydra quiescent-hydra-iy-go-to-char (:color amaranth)
  ;;   "
  ;;     Iy go to character Hydra
  ;;     ^Forward^                    ^Backward^
  ;;     ^^^^^^^^-------------------------------
  ;;     _f_: forward              _b_: backward
  ;;     _n_: continue forward     _p_: continue backward

  ;;     _q_: quit
  ;;     "
  ;;   ("f" iy-go-to-char                   nil)
  ;;   ("n" iy-go-to-char-continue          nil)
  ;;   ("b" iy-go-to-char-backward          nil)
  ;;   ("p" iy-go-to-char-continue-backward nil)
  ;;   ("q" nil                             nil))

  ;; iy seems to have dissapeared!?
#+END_SRC

** Cross Link
I've recently come up with the idea of ad hoc cross linking buffers
together based on the symbol at point.  The basic idea is that you
first invoke it in a buffer creating a link to another buffer on the
first invocation.  It will remember the buffer it was first used with
and cross link to that buffer every time it is invoked from the
starting buffer, until a clear command is called.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref quiescent-cross-link :lexical t
  (defvar quiescent-cross-link-linked-buffer nil
    "The buffer which this buffer is cross linked to.")

  (make-variable-buffer-local 'quiescent-cross-link-linked-buffer)

  (defun quiescent-cross-link ()
    "Cross link symbols in the current buffer to another buffer."
    (interactive)
    (let ((search-symbol (thing-at-point 'symbol)))
      (when (not quiescent-cross-link-linked-buffer)
        (call-interactively 'quiescent-cross-link-set-cross-linked-buffer))
      (pop-to-buffer quiescent-cross-link-linked-buffer)
      (goto-char (point-min))
      (search-forward search-symbol)))

  (defun quiescent-coss-link-reset ()
    "Reset the linked buffer for current buffer."
    (interactive)
    (setq quiescent-cross-link-linked-buffer nil))

  (defun quiescent-cross-link-set-cross-linked-buffer (linked-buffer-name)
    "Set the LINKED-BUFFER-NAME of the buffer to link this buffer to."
    (interactive "bEnter buffer name to link to: ")
    (setq quiescent-cross-link-linked-buffer linked-buffer-name))
#+END_SRC

** Multiple Cursors
I've always heard that multiple cursors is a very good mode.  Until
recently I thought that it might just be a clone of modes from
programs like IntelliJ and Sublime.  What made me decide to try it out
in the end was a package I came across called Mark multiple.  The idea
with this package is that you can mark multiple regions and mark further
regions based on what really marked and then apply edits to all the
marked regions.

It turns out that this functionality is built into multiple cursors.  I
generally do the kind of editing that people advertise from multiple
cursors using macros, but the ability to select further subregions
based on what's already selected is really something that goes beyond
macros.  This is what made me decide to try it out.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref multiple-cursors :lexical t
  (use-package multiple-cursors
    :straight t
    :config
    (progn
      (global-set-key (kbd "s-SPC")   #'mc/edit-lines)
      (global-set-key (kbd "C->")     #'mc/mark-next-like-this)
      (global-set-key (kbd "C-<")     #'mc/mark-previous-like-this)
      (global-set-key (kbd "C-c C-<") #'mc/mark-all-like-this)
      (global-set-key (kbd "s->")     #'mc/skip-to-next-like-this)
      (global-set-key (kbd "s-<")     #'mc/skip-to-previous-like-this)))
#+END_SRC

** IEdit Mode
There is also a widely used package which allows one to edit multiple
occurrences of a symbol in the current buffer.  It's called IEdit mode
and it's available via ELPA.  The difference between it and mc is that
it serves a narrower purpose and so can be lighter weight.  i.e.  if all
you want to do is edit and not run the same generic commands
everywhere that a symbol occurs then IEdit does that a bit more neatly
than mc.  However IEdit isn't as generic as mc.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref iedit :lexical t
  (use-package iedit
      :straight t
      :config (global-set-key (kbd "M-s ,") #'iedit-mode))
#+END_SRC

** "Scroll" Through History
I just read XKCD #1806 and the tool tip says that it would be cool to
bind the scroll wheel to undo and redo /if a program could keep up
with it/.  Well let's see if Emacs can!

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref hiscroll :lexical t
  (define-minor-mode hiscroll-mode
    "Toggle hiscroll-mode.
  Interactively with no argument, this command toggles the mode.
  A positive prefix argument enables the mode, any other prefix
  argument disables it.  From Lisp, argument omitted or nil enables
  the mode, `toggle' toggles the state.

  When hiscroll-mode is enabled the mouse wheel will move the
  current buffer through time (i.e. undo/redo while you scroll.)"
    :init-value nil
    :lighter " HiS"
    :keymap
    '(([mouse-5] . hiscroll-undo)
      ([mouse-4] . hiscroll-redo))
    :group 'hiscroll)

  (defvar hiscroll-undo-direction 'UNDO
    "The direction to go in history of changes for this buffer.")

  (defun hiscroll--correct-direction-and-go (desired-direction)
    "Correct the direction of undoing to DESIRED-DIRECTION and then undo."
    (progn
      (when (not (eq hiscroll-undo-direction desired-direction))
        (setq last-command nil)
        (setq hiscroll-undo-direction desired-direction))
      (undo)))

  (defun hiscroll-undo ()
    "Reverse the direction of history if necessary and then continue undoing."
    (interactive)
    (hiscroll--correct-direction-and-go 'UNDO))

  (defun hiscroll-redo ()
    "Reverse the direction of history if necessary and then continue redoing."
    (interactive)
    (hiscroll--correct-direction-and-go 'REDO))
#+END_SRC

** Recursive Editing
I really like the idea of recursive editing sessions.  I want to be
doing something look somewhere else and come back to where I was by
quitting that short session.  I'm going to bind it to =s-R=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref general-recursive-session :lexical t
  (defun quiescent-general-recursive-edit ()
    "Enter a recursive editing session remembering the window config etc."
    (interactive)
    (save-excursion
      (save-window-excursion
        (recursive-edit))))

  (global-set-key (kbd "s-R") #'quiescent-general-recursive-edit)
#+END_SRC

** Composable
There is a concept in VIM that objects and actions are orthogonal.
i.e.  what you can do can be done to all things.  This is a powerful
idea because it means that you don't have to remember as many bindings
and if any new actions or objects are added they are automatically
actionable by any the other kind.  A realisation that an Emacsen had
was that Emacs could easily support this idea because it already has
actions and objects built in and various commands for using them (just
not by the same name.)  Importantly one can continue using Emacs the
same way even with composable turned on!

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref composable :lexical t
  (eval-and-compile
      (add-to-list 'load-path "~/.emacs.d/lisp/composable.el/")
      (require 'composable)
      (require 'composable-mark)
      (progn (composable-mode)
             (composable-mark-mode)))
#+END_SRC

** Completion Setup
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref completion :lexical t
  <<company-mode>>
  <<company-text-mode-backends>>
  <<company-statistics>>
#+END_SRC

I've long since abandoned this completion file and instead I'm going
to do it all from here with company mode -- which seems to be the best
supported completion framework.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref company-mode :lexical t
  (defun quiescent-company-toggle-frontend ()
    "Switch to completing with a dropdown."
    (interactive)
    (if (equal company-frontends '(company-pseudo-tooltip-frontend))
        (setq company-frontends '(company-preview-frontend))
      (setq company-frontends '(company-pseudo-tooltip-frontend))))

  (defun quiescent-company-complete-selection ()
    "Complete the current selection, unless we're in comint buffers.

  In comint buffers defer to the comint send input command."
    (interactive)
    (if (derived-mode-p 'comint-mode)
        (call-interactively #'comint-send-input)
      (call-interactively #'company-complete-selection)))

  (use-package company
   :straight t
   :hook (((prog-mode text-mode comint-mode) . quiescent-activate-company-mode))
   :config
   (progn
     (defun quiescent-activate-company-mode ()
       "Activate company mode."
       (when (null quiescent-starting-up)
         (company-mode 1)))
     (define-key company-active-map (kbd "C-'")   #'company-complete-selection)
     (define-key company-active-map (kbd "M-'")   #'company-complete-selection)
     (define-key company-active-map (kbd "C-.")   #'company-select-next)
     (define-key company-active-map (kbd "M-.")   #'company-select-next)
     (define-key company-active-map (kbd "C-,")   #'company-select-previous)
     (define-key company-active-map (kbd "M-,")   #'company-select-previous)
     (define-key company-active-map (kbd "M-SPC") #'quiescent-company-toggle-frontend)
     (define-key company-active-map (kbd "C-m")   nil)
     (define-key company-active-map (kbd "C-n")   nil)
     (define-key company-active-map (kbd "C-p")   nil)
     (define-key company-active-map (kbd "<return>") #'quiescent-company-complete-selection)
     (define-key comint-mode-map (kbd "<tab>") #'company-complete-common)
     (global-set-key (kbd "C-'") #'company-complete-selection)
     (global-set-key (kbd "C-.") #'company-complete)
     (global-set-key (kbd "C-,") #'company-complete)
     (advice-add #'company-ispell :around #'quiescent-supress-message-around)
     (setq company-idle-delay 0)
     (setq company-tooltip-idle-delay 5)
     (setq company-tooltip-limit 0)
     (setq company-require-match nil)
     (setq company-frontends '(company-preview-frontend))))

  (defun quiescent-remove-semantic-backend ()
    "Remove the company backend for semantic."
    (remove-function 'company-backends #'company-semantic))

  (add-hook 'python-mode-hook #'quiescent-remove-semantic-backend)

  (defun quiescent-supress-message-around (f &rest args)
    "Supress messages when executing F with ARGS."
    (let ((inhibit-message t))
      (funcall f args)))
#+END_SRC

In text mode I only want company to work from my flyspell dictionary
and then from dabbrev.  I think that the other back ends are slowing
it down quite a bit.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref company-text-mode-backends :lexical t
  (defun quiescent-company-text-mode-hook ()
    "Keep only the backends I want in `text-mode'."
    (when (null quiescent-starting-up)
      (setq-local company-backends '(company-bbdb company-ispell company-dabbrev))))

  (add-hook 'text-mode-hook #'quiescent-company-text-mode-hook)
#+END_SRC

It's useful to keep track of the most used completions per context
because in practice placing these at the top of the list tends to be a
good expericence.  Company has a mode for that called
`company-statistics'.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref company-statistics :lexical t
  (use-package company-statistics
    :straight t
    :config
    (defun quiescent-activate-company-statistics ()
      "Activate `company-statistics-mode'."
      (when (and (null quiescent-starting-up)
                 (boundp 'company-statistics-mode))
        (company-statistics-mode 1)))
    :init (add-hook 'company-mode-hook #'quiescent-activate-company-statistics))
#+END_SRC

** Emacs Complete Lines
Redguardtoo has released a package which attempts to complete the
lines following point based on grep hits in the project.  It looks
amazing for web dev so I'm going to give it a bash.

It turns out though that it's not a package so I'm going to have to do
a manual install of it.  I'll take a look a bit later.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eacl :lexical t
  (use-package eacl
    :straight t
    :config
    (progn
      (global-set-key (kbd "s-<tab>") #'eacl-complete-multiline)
      (global-set-key (kbd "M-s-i")   #'eacl-complete-line)))
#+END_SRC

** Pair Programming
I'm starting to do more and more pair programming and one of the
stumbling blocks which I have is that the person reading my code is
accustomed to a number of things.  The first of which is that their
editor/IDE always has line numbers showing.  The second is that
they'll almost certainly have the current line highlighted and
sometimes outlined.  I've decided to create a mode based on the pair
programming which I'm doing write now and call it "Matt is Watching
Mode".

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref matt-is-watching :lexical t
  (define-minor-mode global-matt-is-watching-mode
    "Toggle global-matt-is-watching-mode.
  Turns on some features which are useful for pair programming.  In
  particular:
   - line numbers
   - hilighting the current line"
    :init-value nil
    :lighter " MiW"
    :global t
    (if global-matt-is-watching-mode
        (progn
          (global-display-line-numbers-mode 1)
          (global-hl-line-mode 1))
      (progn
        (global-display-line-numbers-mode -1)
        (global-hl-line-mode -1))))
#+END_SRC

** RealGUD
RealGUD is a package which aims to provide more debugging support to
Emacs than comes standard.  I'm going to start using it for debugging
from within Emacs where GUD doesn't yet have support for a debugger.
What prompted me to use it was the apparent lack of support for pdb on
Windows.

In order to start using it you must run the following command:
=M-x load-library RET realgud RET=

# I'm not going to load it for now because it fails native compilation.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref realgud :lexical t
  (use-package realgud
      :straight t)
#+END_SRC

** Cleaning up Files
A lot of the code which I work on is poorly formatted and has tabs in
it -_- To rectify this I've written a function which cleans up a file
in one fell swoop.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref clean-file :lexical t
  (defun quiescent-clean-file ()
    "Clean the current file.

  Removes tabs, cleans up whitespace errors and indents."
    (interactive)
    (save-excursion
      (progn
        (mark-whole-buffer)
        (untabify (region-beginning) (region-end))
        (whitespace-cleanup)
        (indent-for-tab-command))))
#+END_SRC

** Compiling
Emacs includes a mode which makes compilation buffers more
interactive.  I've made a couple of adjustments to it.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref compile :lexical t
  (require 'compile)

  ;; Credit: http://stackoverflow.com/questions/13397737/ansi-coloring-in-compilation-mode
  (ignore-errors
    (require 'ansi-color)
    (defun gavenkoa-colorize-compilation-buffer ()
      "Colerise the buffer in compilation mode."
      (when (and (null quiescent-starting-up)
           (eq major-mode 'compilation-mode))
     (ansi-color-apply-on-region compilation-filter-start (point-max))))
    (add-hook 'compilation-filter-hook 'gavenkoa-colorize-compilation-buffer))

  (key-chord-define-global "xr" 'recompile)
#+END_SRC

** Flycheck Mode
Flycheck mode provides interactive syntax checking through integration
with compilers and regular expression based syntax checkers (which it
has built in.) It checks files while your editing and, like Flyspell,
underlines mistakes.  At the moment I use it everywhere, because I'm
yet to decide where I want it to be enabled and it seems pretty useful
so far.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref flycheck :lexical t
  ;; TODO more carefully consider which modes need flycheck
  (use-package flycheck
    :straight t
    :init (add-hook 'prog-mode-hook #'quiescent-enable-flycheck-prog)
    :config
    (defun quiescent-enable-flycheck (&optional rest)
      "Enable flycheck mode.

      Ignore REST."
      (when (null quiescent-starting-up)
        (flycheck-mode 1)))

    (defun quiescent-disable-flycheck (&optional rest)
      "Disable flycheck mode.

      Ignore REST."
      (flycheck-mode -1))
    (defvar quiescent-modes-not-to-activate-flycheck-in '(haskell-mode emacs-lisp-mode rust-mode)
      "Modes in which flycheck should not be activated.

  Usually because of too much overhead in checking.")

    (defun quiescent-enable-flycheck-prog (&optional rest)
      "Decide whether flycheck should be enabled in this prog mode.

  Ignore REST."
      (when (and (null quiescent-starting-up)
                 (not (member major-mode quiescent-modes-not-to-activate-flycheck-in)))
        (flycheck-mode 1)))
    :hook (((latex-mode message-mode
                        org-mode text-mode
                        gfm-mode markdown-mode LaTeX-mode)
            . quiescent-enable-flycheck)))

  (with-eval-after-load "flycheck"
    (progn
      (define-key flycheck-mode-map (kbd "M-n") #'flycheck-next-error)
      (define-key flycheck-mode-map (kbd "M-p") #'flycheck-previous-error)))u

  ;; From http://emacsist.com/10784
  ;; (flycheck-define-checker 'proselint
  ;;   "A linter for prose."
  ;;   :command ("proselint" source-inplace)
  ;;   :error-patterns
  ;;   ((warning line-start (file-name) ":" line ":" column ": "
  ;;          (id (one-or-more (not (any " "))))
  ;;          (message) line-end))
  ;;   :modes (text-mode markdown-mode gfm-mode message-mode latex-mode org-mode))

  ;; (add-to-list 'flycheck-checkers 'proselint)

  (defun quiescent-add-probable-include-dir-for-cpp ()
    "Add a probable include directory clang flycheck.

    We guess that the include dir is probably one up and into
    `include'."
    (when (null quiescent-starting-up)
      (setq flycheck-clang-include-path
            (list (expand-file-name "../include/")))))

  (defun quiescent-set-flycheck-language-standard ()
    "Set the language standard for flycheck."
    (when (null quiescent-starting-up)
      (setq flycheck-clang-language-standard "c++11")))

  (add-hook 'c++-mode-hook
            #'quiescent-set-flycheck-language-standard)
  (add-hook 'c++-mode-hook
            #'quiescent-add-probable-include-dir-for-cpp)
  (add-hook 'c-mode-hook
            #'quiescent-add-probable-include-dir-for-cpp)
#+END_SRC

** Flymake Mode
Flymake is a competitor to Flycheck which is:
 - in core Emacs;
 - was recently remade and vastly improved;

I'd like to try using it over Flycheck because I have a feeling that
(especially considering the man who wrote it) it'll do a better job of
being fast, streamlined and that it'll make better use of current
Emacs features.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref flymake :lexical t
  (require 'flymake)

  (define-key flymake-mode-map (kbd "M-p") #'flymake-goto-prev-error)
  (define-key flymake-mode-map (kbd "M-n") #'flymake-goto-next-error)

  ;; Emacs Lisp

  (defun quiescent-enable-flymake-mode ()
    "Enable `flymake-mode' in the current buffer."
    (when (null quiescent-starting-up)
      (flymake-mode 1)))

  (add-hook 'emacs-lisp-mode-hook #'flymake-mode)
#+END_SRC

** Hide Show Mode
Emacs has a built in mode for hiding and showing source code blocks in
various languages.  I find it useful in java when classes get very big
and you want to see a summary of the methods without the noise, or in
XML where you're interested in the elements at a particular depth.

I toggle between show and hide using a custom snippet I got from the
emacs wiki.

By default show-hide doesn't support folding in HTML and XML very
well.  I use a snippet from the Emacs wiki to solve that.

I've chosen a few language modes to load show hide in.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref hide-show :lexical t
  (defun toggle-hiding (column)
    "Hide or show the sexp at COLUMN (defaulted to the point).

  Requires that `hs-minor-mode' is enabled."
    (interactive "P")
    (if hs-minor-mode
     (if (condition-case nil
           (hs-toggle-hiding)
            (error t))
         (hs-show-all))
     (toggle-selective-display column)))

  ;; Fix XML folding
  (add-to-list 'hs-special-modes-alist
            (list 'nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"
               "<!--"
               'nxml-forward-element
               nil))

  ;; Fix HTML folding
  (dolist (mode '(sgml-mode
            html-mode
            html-erb-mode))
    (add-to-list 'hs-special-modes-alist
           (list mode
                 "<!--\\|<[^/>]*[^/]>"
                 "-->\\|</[^/>]*[^/]>"
                 "<!--"
                 'sgml-skip-tag-forward
                 nil)))

  (use-package hideshow
    :config
    (progn
      (defun quiescent-activate-hs-minor-mode ()
        "Activate `hs-minor-mode'."
        (when (null quiescent-starting-up)
          (hs-minor-mode 1)))
      (global-set-key (kbd "C-=") #'toggle-hiding)
      (add-hook 'c-mode-common-hook   #'quiescent-activate-hs-minor-mode)
      (add-hook 'emacs-lisp-mode-hook #'quiescent-activate-hs-minor-mode)
      (add-hook 'java-mode-hook       #'quiescent-activate-hs-minor-mode)
      (add-hook 'lisp-mode-hook       #'quiescent-activate-hs-minor-mode)
      (add-hook 'perl-mode-hook       #'quiescent-activate-hs-minor-mode)
      (add-hook 'sh-mode-hook         #'quiescent-activate-hs-minor-mode)
      (add-hook 'python-mode-hook     #'quiescent-activate-hs-minor-mode)
      (add-hook 'nxml-mode-hook       #'quiescent-activate-hs-minor-mode)
      (add-hook 'sgml-mode-hook       #'quiescent-activate-hs-minor-mode)
      (add-hook 'html-mode-hook       #'quiescent-activate-hs-minor-mode)))
#+END_SRC

** Paren Mode
I want to have matching parentheses highlighted.  There's a mode for
this too ;P

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref paren :lexical t
  (use-package paren
      :config (progn
                (setq show-paren-style 'parenthesis)
                (show-paren-mode +1)
                (setq show-paren-when-point-inside-paren t)
                (setq show-paren-when-point-in-periphery t)))
#+END_SRC

** Yasnippet
Yasnippet is a powerful snippet editing and insertion engine with
support for transforms in elisp and a lot of available snippets for
various languages.  I have it load snippets from my snippets
directory.  This isn't separate because of OS concerns.  It's separate
because I have to point Yasnippet at it to load it and if were in the
same directory as the snippets which come with Yasnippet then the
snippets would be overridden every time that I upgrade the package.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref yasnippet :lexical t
  ;; From SO: http://emacs.stackexchange.com/questions/12613/convert-the-first-character-to-uppercase-capital-letter-using-yasnippet
  (defun kaushalmodi-capitalize-first-char (string)
    "Capitalize only the first character of the input `STRING'."
    (when (and string (> (length string) 0))
      (let ((first-char (substring string 0 1))
            (rest-str   (substring string 1)))
        (concat (capitalize first-char) rest-str))))


  (use-package yasnippet
      :straight t
      :init (progn
              (yas-global-mode 1)
              (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")))
#+END_SRC

There's a strange interaction between company mode and yasnippet.  If
you're using yasnippet and company together then sometimes you can be
busy completing something and not be able to call the yas completion
of the thing at point.  I found an SO post addressing this issue but
it has a lot more than I need because it tries to make tab super
powerful.  I don't want to change Tab because I have auto completion
with company.  Instead I'm going to just bind tab in company mode to
complete with company or yasnippet from their post.  For reference:
[[https://emacs.stackexchange.com/questions/7908/how-to-make-yasnippet-and-company-work-nicer#7925]].

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref company-or-yas-on-tab :lexical t
  (defun check-expansion ()
    (save-excursion
      (if (looking-at "\\_>") t
        (backward-char 1)
        (if (looking-at "\\.") t
      (backward-char 1)
      (if (looking-at "->") t nil)))))

  (defun do-yas-expand ()
    (let ((yas-fallback-behavior 'return-nil))
      (yas-expand)))

  (defun tab-complete-or-next-field ()
    (interactive)
    (if (or (not yas-minor-mode)
        (null (do-yas-expand)))
        (if company-candidates
        (company-complete-selection)
      (if (check-expansion)
        (progn
          (company-manual-begin)
          (if (null company-candidates)
          (progn
            (company-abort)
            (yas-next-field))))
        (yas-next-field)))))

  (defun expand-snippet-or-complete-selection ()
    (interactive)
    (if (or (not yas-minor-mode)
            (null (do-yas-expand))
            (company-abort))
        (company-complete-common)))

  (defun abort-company-or-yas ()
    (interactive)
    (if (null company-candidates)
        (yas-abort-snippet)
      (company-abort)))

  (with-eval-after-load "company-mode"
    (with-eval-after-load "yasnippet"
      (define-key company-active-map [tab] 'expand-snippet-or-complete-selection)
      (define-key yas-minor-mode-map (kbd "TAB") nil)
      (define-key yas-keymap (kbd "TAB") 'tab-complete-or-next-field)
      (define-key yas-keymap (kbd "C-g") 'abort-company-or-yas)))
#+END_SRC

** Skeletons
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref skeletons :exports none :lexical t
  <<q-skeletons>>
#+END_SRC
Skeletons is another templating system which provides features similar
to Yasnippet.  Skeletons defined snippets using an Emacs Lisp
macro.  First line of the macro is a doc string and subsequent lines
are the lines to generate.  You can generate skeletons which accept
arbitrarily many inputs by creating a skeleton which accept a skeleton
as input.  In doing so the skeleton is not completed until its sub-
skeletons have completed.

I've also decided to use skeletons to make general SQL statements.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref q-skeletons :lexical t
  (define-skeleton quiescent-common-lisp-skeleton-advent-of-code
        "Insert an advent of code Common Lisp file."
      ""
      ";;; " (setq quiescent-module-name (file-relative-name (file-name-sans-extension buffer-file-name))) " --- My solution to " quiescent-module-name " -*-\n"
      "\n"
      ";;; Commentary:\n"
      ";; My solution to advent of code: " quiescent-module-name "\n"
      "\n"
      ";;; Code:\n"
      "\n"
      "(ql:quickload \"iterate\")\n"
      "\n"
      "(load \"read-file.lisp\")\n"
      "(load \"graph.lisp\")\n"
      "(load \"debug.lisp\")\n"
      "(load \"hash.lisp\")\n"
      "\n"
      "(defpackage :" quiescent-module-name "\n"
      "  (:use :common-lisp)\n"
      "  (:use :debug)\n"
      "  (:use :graph)\n"
      "  (:use :read-file)\n"
      "  (:use :hash)\n"
      "  (:use :iter))\n"
      "\n"
      "(in-package :" quiescent-module-name ")\n"
      "\n"
      ";; # PART 1:\n"
      "\n"
      "(defun " quiescent-module-name "-part-1 (input-elements)\n"
      "  \"Run my solution to part one of the problem on the input in INPUT-ELEMENTS.\"\n"
      ")\n"
      "\n"
      ";; # PART 2:\n"
      "\n"
      "(defun " quiescent-module-name "-part-2 (input-elements)\n"
      "  \"Run my solution to part two of the problem on the input in INPUT-ELEMENTS.\"\n"
      ")\n\n"
      ";; Scratch area:\n\n"
      "(progn\n"
      "  (format t \"~%********** SCRATCH **********~%\")\n"
      "  (let ((input-1 '())\n"
      "        (expected-1 '())\n"
      "        (input-2 '())\n"
      "        (expected-2 '()))\n"
      "    (format t \"~%Part 1:~%Expected: ~s~%     Got: ~s~%\" expected-1 ("quiescent-module-name "-part-1 input-1))\n"
      "    (format t \"~%Part 2:~%Expected: ~s~%     Got: ~s~%\" expected-2 ("quiescent-module-name "-part-2 input-2))))\n"
      "\n"
      ";; Run the solution:\n"
      "\n"
      "(progn\n"
      "  (format t \"~%********** OUTPUT **********~%\")\n"
      "  (let ((input-1 (file-lines \""quiescent-module-name"-part-1\"))\n"
      "        (input-2 (file-lines \""quiescent-module-name"-part-1\")))\n"
      "    (format t \"~%Part 1: ~s~%\" ("quiescent-module-name "-part-1 input-1))\n"
      "    (format t \"~%Part 2: ~s~%\" ("quiescent-module-name "-part-2 input-2))))\n"
      "\n")

  (define-skeleton quiescent-emacs-lisp-skeleton-advent-of-code
      "Insert an advent of code Emacs Lisp file."
    ""
    ";;; " (setq quiescent-module-name (file-relative-name (file-name-sans-extension buffer-file-name))) " --- My solution to " quiescent-module-name " -*- lexical-binding: t; -*-\n"
    "\n"
    ";;; Commentary:\n"
    ";; My solution to advent of code: " quiescent-module-name "\n"
    "\n"
    ";;; Code:\n"
    "\n"
    ";; # PART 1:\n"
    "\n"
    "(require 'cl-lib)\n"
    "\n"
    "(defun " quiescent-module-name "-part-1 (input-file)\n"
    "  \"Run my solution to part one of the problem on the input in INPUT-FILE.\"\n"
    ")\n"
    "\n"
    ";; # PART 2:\n"
    "\n"
    "(defun " quiescent-module-name "-part-2 (input-file)\n"
    "  \"Run my solution to part two of the problem on the input in INPUT-FILE.\"\n"
    ")\n"
    "\n"
    ";; Run the solution:\n"
    "\n"
    "(progn\n"
    " (message \"\\n********** OUTPUT **********\")\n"
    " (let ((input-1 (with-temp-buffer\n"
    "                  (find-file-literally \"" quiescent-module-name "-part-1\")\n"
    "                  (buffer-substring (point-min)\n"
    "                                    (point-max))))\n"
    "       (input-2 (with-temp-buffer\n"
    "                  (find-file-literally \"" quiescent-module-name "-part-1\")\n"
    "                  (buffer-substring (point-min)\n"
    "                                    (point-max)))))\n"
    "  (message \"Part 1: %s\" ("quiescent-module-name "-part-1 input-1))\n"
    "  (message \"Part 2: %s\\n\" ("quiescent-module-name "-part-2 input-2))))\n"
    "\n"
    "(provide '" quiescent-module-name ")\n"
    ";;; " quiescent-module-name " ends here\n")

  ";;; day9-2 --- My solution to day9-2 -*- lexical-binding: t; -*-"
  "\n"
  ";;; Commentary:\n"
  ";; My solution to advent of code: day9-2\n"
  "\n"
  ";;; Code:\n"
  "\n"
  ";; # PART 1:\n"
  "\n"
  "(require 'cl-lib)\n"
  "\n"
  "(defvar run-from-batch nil \n"
  "  \\\"Whether this was run froom batch.\n"
  "\n"
  "We only want long running executions to be done from the terminal\n"
  " so that Emacs doesn't hang.\")\n"
  "\n"
  "(defun day9-2-part-1 (input-file)\n"
  "  \\\"Run my solution to part one of the problem on the input in INPUT-FILE.\\\"\n"
  "  )\n"
  "\n"
  "(let* ((test-input    \"\")\n"
  "       (test-computed (day9-2-part-1 test-input))\n"
  "       (test-ans      0))\n"
  "  (message \"Expected: %s\n    Got:      %s\" test-ans test-computed))\n"
  "\n"
  ";; # PART 2:\n"
  "\n"
  "(defun day9-2-part-2 (input-file)\n"
  "  \\\"Run my solution to part two of the problem on the input in INPUT-FILE.\\\"\n"
  "  )\n"
  "\n"
  "(let* ((test-input    \"\")\n"
  "       (test-computed (day9-2-part-2 test-input))\n"
  "       (test-ans      0))\n"
  "  (message \"Expected: %s\n    Got:      %s\" test-ans test-computed))\n"
  "\n"
  ";; Run the solution:\n"
  "\n"
  "(progn\n"
  "  (message \\\"\\n********** OUTPUT **********\\\")\n"
  "  (let ((input-1 (save-window-excursion\n"
  "                   (with-temp-buffer\n"
  "                     (find-file-literally \\\"day9-2-part-1\\\")\n"
  "                     (buffer-substring (point-min)\n"
  "                                       (point-max)))))\n"
  "        (input-2 (save-window-excursion\n"
  "                   (with-temp-buffer\n"
  "                     (find-file-literally \\\"day9-2-part-1\\\")\n"
  "                     (buffer-substring (point-min)\n"
  "                                       (point-max))))))\n"
  "    (message \\\"Part 1: %s\\\" (day9-2-part-1 input-1))\n"
  "    (message \"Part 2: %s\n\" (day9-2-part-2 input-2))))\n"
  "\n"
  "(provide 'day9-2)\n"
  ";;; day9-2 ends here\n"


  (define-skeleton quiescent-emacs-lisp-skeleton
      "Insert the default file template for an Emacs Lisp file."
    ""
    ";;; " (setq quiescent-module-name (file-relative-name (file-name-sans-extension buffer-file-name))) " --- " (skeleton-read "Brief description: ") " -*- lexical-binding: t; -*-\n"
    "\n"
    ";;; Commentary:\n"
    "\n"
    ";;; Code:\n"
    "\n"
    "(provide '" quiescent-module-name ")\n"
    ";;; " quiescent-module-name " ends here\n")

  (define-skeleton quiescent-java-pojo
      "Rapidly create a Java Pojo class."
    "ClassName: "
    "package ...;\n" ;; TODO improve to auto insert the package/write the insert package function
    "\n"
    "public class " str " {\n"
    "    /**\n"
    "      * Create an empty " str "\n"
    "      */\n"
    "    public " str "() {}\n"
    (""
     "    private " (setq type (skeleton-read "Member Type: ")) " " (setq name (skeleton-read "Member Name: ")) ";\n"
     "\n"
     "    /**\n"
     "     * Set the value of " name "\n"
     "     * @param " name "\n"
     "     *     The value to set " name " to\n"
     "     */\n"
     "    public void set" (kaushalmodi-capitalize-first-char name) " (final " type " " name ") {\n"
     "        this." name " = " name ";\n"
     "    }\n"
     "\n"
     "    /**\n"
     "     * Get the value of " name "\n"
     "     * @return The value of " name "\n"
     "     */\n"
     "    public " type " get" (kaushalmodi-capitalize-first-char name) " () {\n"
     "        return " name ";\n"
     "    }\n")
    "}\n")

  (define-skeleton quiescent-java-getter-skeleton
      "Insert a getter"
    ""
    "    /**\n"
    "     * Get the value of " (setq name (skeleton-read "Member Name: ")) "\n"
    "     * @return The value of " name "\n"
    "     */\n"
    "    public " (setq type (skeleton-read "Member Type: ")) " get" (kaushalmodi-capitalize-first-char name) " () {\n"
    "        return " name ";\n"
    "    }\n")

  (define-skeleton quiescent-java-setter-skeleton
      "Insert a setter"
    ""
    "    /**\n"
    "     * Set the value of " (setq name (skeleton-read "Member Name: ")) "\n"
    "     * @param " name "\n"
    "     *     The value to set " name " to\n"
    "     */\n"
    "    public void set" (kaushalmodi-capitalize-first-char name) " (final " (skeleton-read "Member Type: ") " " name ") {\n"
    "        this." name " = " name ";\n"
    "    }\n")

  (use-package s
      :straight t)

  (defun quiescent-abbreviate-table-name (table-name)
    "Produce the abbreviation of TABLE-NAME."
    (s-join "" (mapcar (lambda (x)
                         (downcase (substring x 0 1)))
                       (split-string table-name "_"))))

  (define-skeleton quiescent-sql-select
      "Rapidly create SQL select statement."
    ""
    "SELECT *\n"
    "FROM   " (setq table-name (skeleton-read "Table name: ")) " "
    (setq abbrev-table-name (quiescent-abbreviate-table-name table-name)) "\n"
    "WHERE  " abbrev-table-name "." (skeleton-read "Column: ") " = '" (skeleton-read "Value: ") "'\n"
    (""
     "AND    " abbrev-table-name "." (skeleton-read "Column: ") " = '" (skeleton-read "Value: ") "'\n")
    ";")

  (require 'calendar)

  (defun quiescent-absolute-date-to-string (absolute-date)
    "Convert the given `ABSOLUTE-DATE' into a formatted string."
    (let (gregorian-date)
      (setq gregorian-date (calendar-gregorian-from-absolute absolute-date))
      (format "%04d-%02d-%02d"
              (elt gregorian-date 2)     ; month
              (elt gregorian-date 0)     ; day
              (elt gregorian-date 1))))

  (define-skeleton quiscent-java-class-comment
      "Insert a class comment for a java class."
    ""
    "/**\n"
    "* " (skeleton-read "Comment: ") "\n"
    "* @author " (insert user-full-name) "\n"
    "* @date " (quiescent-absolute-date-to-string (org-today)) "\n"
    (if (setq task-number (skeleton-read "TaskNumber: ")) (concat " * Task Number: " task-number "\n") "")
    "*/\n")

  (define-skeleton quiscent-java-class
      "Insert a class comment for a java class."
    ""
    "public class " (setq class-name (file-name-sans-extension (buffer-name))) " {\n"
    "    public " class-name "() {\n"
    "    }\n"
    "}\n")

  (defun quiescent-dash-to-camel (symbol)
    "Convert SYMBOL into camel case."
    (with-temp-buffer
      (insert (format "%s" symbol))
      (beginning-of-line)
      (when (> (buffer-size) 0)
        (forward-word)
        (while (not (= (point) (point-max)))
          (call-interactively #'capitalize-word))
        (replace-regexp-in-string "-" ""
                                  (buffer-substring (point-min) (point-max))))))

  (defun quiescent-dash-to-pascal (symbol)
    "Convert SYMBOL into pascal case."
    (with-temp-buffer
      (insert (format "%s" symbol))
      (beginning-of-line)
      (when (> (buffer-size) 0)
        (while (not (= (point) (point-max)))
          (call-interactively #'capitalize-word))
        (replace-regexp-in-string "-" ""
                                  (buffer-substring (point-min) (point-max))))))

  (define-skeleton quiescent--react-function
      "Insert a react Function component."
    ""
    "import React from 'react';\n"
    "\n"
    "export const "
    (quiescent-dash-to-camel
     (file-name-sans-extension
      (file-name-nondirectory (buffer-file-name))))
    " = ("
    (""
     str ", ")
    ") => "
    "(\n"
    "    <div></div>\n"
    ");\n")
#+END_SRC

** Paredit
Paredit is a package which only allows edits to the abstract syntax
tree in lisp modes.  This enforces the structure of code to always be
correct and allows for fast robust manipulation of the way code is
interpreted and executed.

I've enabled paredit in various lisp modes as suggested by [[http://www.emacswiki.org/emacs/ParEdit][it's
documentation on the Emacs wiki]].  I've also included a patch from the
Emacs wiki which prevents hippi-expand from inserting an extra
parenthesis in paredit mode.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref paredit :lexical t
  (use-package paredit
    :straight t
    :config (progn
              (defun quiescent-activate-paredit-mode ()
                "Activate paredit mode."
                (when (null quiescent-starting-up)
                  (enable-paredit-mode)))
              (define-key paredit-mode-map (kbd "C-M-n") #'forward-list)
              (define-key paredit-mode-map (kbd "C-M-p") #'backward-list)
              (add-hook 'emacs-lisp-mode-hook                  #'quiescent-activate-paredit-mode)
              (add-hook 'eval-expression-minibuffer-setup-hook #'quiescent-activate-paredit-mode)
              (add-hook 'ielm-mode-hook                        #'quiescent-activate-paredit-mode)
              (add-hook 'lisp-mode-hook                        #'quiescent-activate-paredit-mode)
              (add-hook 'lisp-interaction-mode-hook            #'quiescent-activate-paredit-mode)
              (add-hook 'scheme-mode-hook                      #'quiescent-activate-paredit-mode)
              (add-hook 'cider-mode-hook                       #'quiescent-activate-paredit-mode)
              (add-hook 'cider-repl-mode-hook                  #'quiescent-activate-paredit-mode)
              (add-hook 'slime-repl-mode-hook                  #'quiescent-activate-paredit-mode)
              (add-hook 'racket-mode-hook                      #'quiescent-activate-paredit-mode)
              (add-hook 'racket-repl-mode-hook                 #'quiescent-activate-paredit-mode)))
#+END_SRC
** Electric Pair Mode
So Emacs has a built in mode for pairing brackets.  It looks a lot
simpler than smart parens and I think that because of the nature of it
being integrated with Emacs proper it'll "just work" with everything
else in my Emacs without having any irritating edge cases to deal
with.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref electric-pair :lexical t
  (require 'elec-pair)

  (defun quiescent-activate-electric-pair ()
    "Activate electric pair local mode."
    (when (null quiescent-starting-up)
      (electric-pair-local-mode)))

  (mapc (lambda (mode-hook) (add-hook mode-hook #'quiescent-activate-electric-pair))
     '(js-mode-hook
       js2-mode-hook
       rjsx-mode-hook
       python-mode-hook
       typescript-mode-hook
       sh-mode-hook
       css-mode-hook
       haskell-mode-hook
       eshell-mode-hook
       restclient-mode-hook
       scala-mode-hook
       java-mode-hook
       conf-unix-mode-hook
       c++-mode-hook
       yaml-mode-hook
       ruby-mode-hook
       intero-repl-mode-hook
       makefile-mode-hook
       rust-mode-hook
       rustic-mode-hook
       conf-mode-hook
       inferior-python-mode-hook
       inf-ruby-mode-hook
       enh-ruby-mode-hook
       ess-r-mode-hook
       inferior-ess-r-mode-hook
       terraform-mode-hook
       c-mode-hook
       csharp-mode-hook))

  (add-to-list 'electric-pair-pairs (cons ?\( ?\)))
#+END_SRC

*** Notes about ~elec-pair~
**** Not a Bug: Comments with lists across lines
When there's a comment with a list across lines then it finds that
things are unbalanced.  This can be tested by moving forward list in
the current buffer until Emacs errors out.  I wonder whether there's a
way of fixing this problem.

ADDENDUM: It looks like the problem is actually that it finds
unbalanced pairs in comments and thinks that the current pair is
unbalanced.

I've since discovered that this is behaving as it was
designed. There's something which you have to set (not sure where it
was always this way) which ignores the balanced parentheses in
comments when scanning.  Scanning is used by ~electric-pair~ to help
you keep brackets balanced.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref electric-pair-ignore-comments :lexical t
  (setq-local parse-sexp-ignore-comments t)
#+END_SRC

** Electric Layout
Emacs also has a feature to insert newlines after particular
characters.  For example, when you insert an open curly brace it'll
insert a newline and indent it.  This assumes that you're opening a
block or starting the definition of some sort of object literal.

#+begin_src  emacs-lisp :tangle no :noweb yes :noweb-ref electric-layout :lexical t
  (require 'electric)

  (defun quiescent-activate-electric-layout ()
    "Activate electric layout local mode."
    (when (null quiescent-starting-up)
      (electric-layout-local-mode t)))

  (defun quiescent-disable-electric-layout ()
    "Disable electric layout local mode."
    (when (null quiescent-starting-up)
      (electric-layout-local-mode -1)))

  (mapc (lambda (mode-hook) (add-hook mode-hook #'quiescent-activate-electric-layout))
        '(js-mode-hook
          js2-mode-hook
          python-mode-hook
          typescript-mode-hook
          sh-mode-hook
          css-mode-hook
          haskell-mode-hook
          eshell-mode-hook
          restclient-mode-hook
          scala-mode-hook
          java-mode-hook
          conf-unix-mode-hook
          c++-mode-hook
          yaml-mode-hook
          ruby-mode-hook
          intero-repl-mode-hook
          makefile-mode-hook
          rust-mode-hook
          rustic-mode-hook
          conf-mode-hook
          inferior-python-mode-hook
          inf-ruby-mode-hook
          enh-ruby-mode-hook
          ess-r-mode-hook
          inferior-ess-r-mode-hook
          terraform-mode-hook
          c-mode-hook))

  (mapc (lambda (mode-hook) (add-hook mode-hook #'quiescent-disable-electric-layout))
        '(rjsx-mode-hook))

  (make-variable-buffer-local 'electric-layout-rules)

  (defun quiescent-setup-electric-layout-js2-mode ()
    "Setup electric layout for js2-mode."
    (progn))

  (add-hook 'js2-mode-hook #'quiescent-setup-electric-layout-js2-mode)
  (add-hook 'rjsx-mode-hook #'quiescent-setup-electric-layout-js2-mode)
#+end_src

** Save Place
This is a cool mode which I discovered in the Emacs 25 NEWS over on
Mickey's website.  You can tell Emacs to remember where you were in
every file you open *mind blown*.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref save-place :lexical t
  (use-package saveplace
      :defer 10
      :init (save-place-mode 1))
#+END_SRC

** Narrowing
Emacs has a system where you can narrow the scope of what you can
edit.  The package usually hides everything else while you're narrowed
which is slightly irritating because you might want to have some
context to what you're busy editing.  Thankfully abo-abo has an answer
to that: fancy-narrow.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref fancy-narrow :lexical t
  (use-package fancy-narrow
      :straight t
      :config (fancy-narrow-mode))
#+END_SRC

** Emacs Refactor
I recently had the need to grab code of a buffer and put it into
functions just to organise it.  It turns out that there's a
refactoring package for that.  The suggestion is to bind it to
=M-<ENTER>= ... I wonder why ;) The more I do this, the more my Emacs
becomes closer to an IDE.  I suppose that the needs direct where I end
up with this.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref emacs-refactor :lexical t
  (use-package emr
    :straight t
    :config
    (progn
      (defun quiescent-emr-initialize ()
        "Initialise `emr', but only if it's been loaded."
        (when (and (null quiescent-starting-up)
                   (boundp 'emr-initialize))
          (emr-initialize)))
      (define-key prog-mode-map (kbd "M-RET") 'emr-show-refactor-menu)
      (add-hook 'prog-mode-hook #'quiescent-emr-initialize)))
#+END_SRC

** Temp Buffers
Sometimes I want to see what a piece of code would look like in a temp
buffer in the correct mode.  For example, if I've been given some JSON
but it's all flat then I'd want to see what the structure looks like
rather than seeing the flat string.

In this section I hope to create a utility function which will detect
the kind of content in the current region and put that into an
appropirate buffer with the correct mode and preprocessing already
done.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref temp-view :lexical t
  <<temp-view-format-eshell>>

  (use-package json-mode
    :straight t)

  (defvar *temp-view-produce-output* nil
    "If non-nil then all functions which would create a buffer instead produce the output.")

  (defun temp-view-region (beg end &optional produce-output)
    "View the region [BEG, END) from the current in a temp buffer.

  Tries to guess the kind of content and setup a veiw of that data
  which is appropirate.

  If PRODUCE-OUTPUT is non-nil then don't create a buffer, instead
  produce the formatted text as output."
    (interactive "r")
    (let ((region           (buffer-substring beg end))
          (*temp-view-produce-output* produce-output))
      (pcase (temp-view-guess-data-type region)
        ('XML  (temp-view-xml region))
        ('HTML (temp-view-html region))
        ('JSON (temp-view-json region)))))

  (defvar temp-view-region-match-alist
    '(("\\(<div>\\)\\|\\(<body>\\)\\(<head>\\)" . HTML)
      ("<[a-z]+>.*</[a-z]+>" . XML)
      ("{.*\\(\\(\n\\)\\|\\(.*\\)\\).*\\(\\(\"[a-z0-9]+\"\\)\\|\\([a-z0-9]+\\)\\):" . JSON))
    "An alist of regular expressions to match text to a type of text.

  Note that ordering is important.  The first match will be the one
  which ends up being reflected.")

  (defun temp-view-guess-data-type (text)
    "Guess what kind of data TEXT is."
    (let (result)
      (dolist (matcher temp-view-region-match-alist result)
        (when (and (not result)
                   (string-match (car matcher) text))
          (setq result (cdr matcher))))))

  (defun temp-view-insert-xml (mode text)
    "Insert TEXT, format xml like data and then activate MODE."
    (progn
      (insert text)
      (goto-char (point-min))
      (while (search-forward "><" nil t nil)
        (replace-match ">\n<"))
      (funcall mode)
      (indent-region (point-min) (point-max))))

  (defun temp-window-xml-like (buffer-name mode text)
    "Create a temp buffer named BUFFER-NAME in MODE containing TEXT."
    (if *temp-view-produce-output*
        (with-temp-buffer
          (temp-view-insert-xml mode text)
          (buffer-substring (point-min) (point-max)))
      (prog1
          (switch-to-buffer-other-window
           (generate-new-buffer buffer-name))
        (temp-view-insert-xml mode text))))

  (defun temp-view-xml (text)
    "View TEXT in a temp buffer setup for viewing xml."
    (temp-window-xml-like "*temp-view-xml*" #'nxml-mode text))

  (defun temp-view-html (text)
    "View TEXT in a temp buffer setup for viewing html."
    (temp-window-xml-like "*temp-view-html*" #'web-mode text))

  (defun temp-view-insert-json (text)
    "Insert TEXT into the buffer at point, activate `json-mode' and format the text."
    (progn
      (insert text)
      (goto-char (point-min))
      (json-mode)
      (json-pretty-print (point-min) (point-max))))

  (defun temp-view-json (text)
    "View TEXT in a temp buffer setup for viewing json."
    (if *temp-view-produce-output*
        (with-temp-buffer
          (temp-view-insert-json text)
          (buffer-substring (point-min) (point-max)))
      (prog1
          (switch-to-buffer-other-window
           (generate-new-buffer "*temp-view-json*"))
        (temp-view-insert-json text))))

  (global-set-key (kbd "s-v") #'temp-view-region)
#+END_SRC

I've come to realise that I can also automatically detect this kind of
content in the output of eshell.  I think that the heuristic has to
have a cut off so that I don't try to do it to extremely long lines,
but the idea is that I just iterate over lines detecting content to
format and format it!

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref temp-view-format-eshell :lexical t
  (defun quiescent-point-at-start-of-line ()
    "Produce the point at the start of the line."
    (save-excursion
      (beginning-of-line)
      (point)))

  (defun quiescent-point-at-end-of-line ()
    "Produce the point at the end of the line."
    (save-excursion
      (end-of-line)
      (point)))

  ;; Use eshell after prompt hook here for guessing content
  (defun quiescent-format-previous-content ()
    "Try to guess the format of the previous content in eshell and format it."
    (save-excursion
      (progn
        (forward-line)
        (while (not (= (point) (point-max)))
          (when (temp-view-guess-data-type (thing-at-point 'line t))
            (let ((original-buffer  (current-buffer))
                  (formatted        (temp-view-region (quiescent-point-at-start-of-line)
                                                      (quiescent-point-at-end-of-line)
                                                      t)))
              (beginning-of-line)
              (kill-line)
              (insert formatted)))
          (forward-line)))))

  ;; Not working and a bit too slow for now
  ;; (add-hook 'eshell-after-prompt-hook #'quiescent-format-previous-content)

#+END_SRC

** Compilation
Some compilation outputs aren't properly parsed by the built in
regexps which come with Emacs.  You need to add a regexp to the list
of regexps which it uses for things like node for example.  This is
based on
https://benhollis.net/blog/2015/12/20/nodejs-stack-traces-in-emacs-compilation-mode/.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref compilation-regexps :lexical t
  (add-to-list 'compilation-error-regexp-alist-alist
               '(node "^[  ]+at \\(?:[^\(\n]+ \(\\)?\\([a-zA-Z\.0-9_/-]+\\):\\([0-9]+\\):\\([0-9]+\\)\)?$"
                      1 ;; file
                      2 ;; line
                      3 ;; column
                      ))
  (add-to-list 'compilation-error-regexp-alist
               'node)

  (add-to-list 'compilation-error-regexp-alist-alist
               '(npm "(\\(.*\..*?\\):\\([0-9]*\\):\\([0-9]*\\)"
                     1 ;; file
                     2 ;; line
                     3 ;; column
                     ))
  (add-to-list 'compilation-error-regexp-alist
               'npm)

  (add-to-list 'compilation-error-regexp-alist-alist
               '(tslint "Error at \\(.*\\):\\([0-9]+\\):\\([0-9]+\\)"
                        1 ;; file
                        2 ;; line
                        3 ;; column
                        ))
  (add-to-list 'compilation-error-regexp-alist
               'tslint)

  (add-to-list 'compilation-error-regexp-alist-alist
               '(mocha "(\\(.*\..*?\\):\\([0-9]*\\):\\([0-9]*\\)"
                       1 ;; file
                       2 ;; line
                       3 ;; column
                       ))
  (add-to-list 'compilation-error-regexp-alist
               'mocha)

  (add-to-list 'compilation-error-regexp-alist-alist
               '(mocha-ts "^\\([^ ]+\\) (\\([0-9]+\\),\\([0-9]+\\))"
                     1 ;; file
                     2 ;; line
                     3 ;; column
                     ))
  (add-to-list 'compilation-error-regexp-alist
               'mocha-ts)

  (add-to-list 'compilation-error-regexp-alist-alist
               '(webpack "\\(\\./[/_-a-zA-Z0-9]+\\.[a-z]+\\) ?\\([0-9]+:[0-9]+\\|$\\)"
                         1 ;; file
                         2 ;; line
                         3 ;; column
                         ))
  (add-to-list 'compilation-error-regexp-alist
               'webpack)

  (add-to-list 'compilation-error-regexp-alist-alist
               '(ng "\\([^ \n]+\\)(\\([0-9]+\\),\\([0-9]+\\)):"
                         1 ;; file
                         2 ;; line
                         3 ;; column
                         ))
  (add-to-list 'compilation-error-regexp-alist
               'ng)

  (add-to-list 'compilation-error-regexp-alist-alist
               '(eslint "\\(^/.*\\.jsx?$\\)\n +\\([0-9]+\\):\\([0-9]+\\)"
                        1 ;; file
                        2 ;; line
                        3 ;; column
                        ))

  (add-to-list 'compilation-error-regexp-alist
               'eslint)
#+END_SRC

** Random Test Data
I need to generate test data quite a bit when I'm writing unit tests.
This can be time consuming.  It's also difficult to macro it; so
instead I'm going to provide a couple of functions to generate useful
random data here and then use them in macros.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref random-data-here :lexical t
  (defvar quiescent-random-int-threshold 20000
    "A threshold for the randomly generated integers.")

  (defun quiescent-insert-reasonable-random-int-here ()
    "Insert a reasonable random int at point."
    (interactive)
    (insert (format "%s" (mod (abs (random)) quiescent-random-int-threshold))))
#+END_SRC

** Editor Config
There is a project out there which is intended to help people write
code which conforms with how everyone on the project is writing code.
It's called editor config and there is, of course, an integration for
Emacs.  It requires that the core binary is installed so I've gone
ahead and installed that too.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref editor-config :lexical t
  (use-package editorconfig
   :straight t
   :init (with-eval-after-load "editorconfig"
           (editorconfig-mode 1)))
#+END_SRC

** Eval on Save
My experiment with =live-eval= was partly a success but had some faults:
 1. If you were busy naming a =defun= then you would have tonnes of
    spurious =defuns= added to the environment.
 2. It would hang Emacs.
 3. It would move the point around.
 4. It was hard to control when it should be doing it's work.

A second attempt at a similar thing would be to simply =eval= the
whole buffer, form by form, whenever I save the buffer to file.  That
way I can get completion on functions which I've just run, have forms
which do smaller tests, run the whole time and not have to deal with
the above problems.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eval-on-save :lexical t
  (use-package eros
    :straight t)

  (defconst eval-on-save-modes-to-save-in '(emacs-lisp-mode)
    "Modes in which we should eval on save.")

  (defun eval-on-save ()
    "Evaluate the whole buffer and add overlays to each form."
    (when (member major-mode eval-on-save-modes-to-save-in)
      (ignore-errors
     (save-excursion
       (when (not (string-match "\\.org$"
                       (buffer-file-name)))
         (goto-char (point-min))
         (while (eval-on-save-forward-sexp-w/o-error)
           (eval-on-save-result-overlay-for-form (eval-on-save-eval-form-at-point))))))))

  (defvar eval-on-save-evaluator nil
    "The function to call to evaluate a form.")

  (make-variable-buffer-local 'eval-on-save-evaluator)

  (defun eval-on-save-result-overlay-for-form (result)
    "Produce a result overlay (using eros) at point for RESULT."
    (eros--make-result-overlay (format "%s" result)
      :where (save-excursion (point))
      :duration 20))

  (defun eval-on-save-eval-form-at-point ()
    "Eval the form at point."
    (funcall eval-on-save-evaluator (thing-at-point 'sexp t)))

  (defun eval-on-save-forward-sexp-w/o-error ()
    "Go forward by an sexp and if we hit an error produce nil."
    (condition-case nil
     (progn
       (forward-sexp)
       (not (= (point) (point-max))))
      (error nil)))


  (defun eval-on-save-backward-sexp-w/o-error ()
    "Go forward by an sexp and if we hit an error produce nil."
    (condition-case nil
     (progn
       (forward-sexp -1)
       (not (= (point) (point-max))))
      (error nil)))

  (defun eval-on-save-emacs-lisp-eval (form-string)
    "Call Emacs eval with the given FORM-STRING using lexical scope."
    (ignore-errors (eval (read form-string) t)))

  (defun eval-on-save-setup-emacs-lisp ()
    "Setup live evaluation for Emacs Lisp mode."
    (interactive)
    (progn
      (setq eval-on-save-evaluator #'eval-on-save-emacs-lisp-eval)
      (add-hook 'after-save-hook #'eval-on-save)))
#+END_SRC

** Too Long Lines
Emacs has a problem...  It can't edit lines which are too long.  This
is caused by it's implementation of fontification and other line
sensitive features on it's representation of text -- a gap buffer.
See [[https://nullprogram.com/blog/2017/09/07/][this article]] for an explanation of gap buffers.

#+BEGIN_SRC emacs-lisp  :tangle no :noweb yes :noweb-ref too-long-lines :lexical t
  (use-package too-long-lines-mode
      :load-path "~/.emacs.d/lisp/too-long-lines-mode/"
      :config (too-long-lines-mode 1))
#+END_SRC

** Ediff Hacks
Emacs has a bunch of tools for diffing and conflict resolution built
in.  e.g. if you want something which can be used to choose between
options at point and move between conflicts in one buffer then
=smerge= will do everything you need.

There's also a much more comprehensive diffing package which has
integrations with the built in VC package.  It's called =ediff=.  With
it you can diff directories and files and you can resolve conflicts.

Something which I've always wished a diffing tool would have is the
choice of putting both options into the result buffer.  Thankfully
killdash9 on SO has the answer [[https://stackoverflow.com/questions/9656311/conflict-resolution-with-emacs-ediff-how-can-i-take-the-changes-of-both-version][here]]!

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref ediff-accept-both :lexical t
  (require 'ediff)

  (defun ediff-copy-both-to-C ()
    "Copy both regions to the result buffer."
    (interactive)
    (ediff-copy-diff ediff-current-difference nil 'C nil
               (concat
                (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

  (defun add-d-to-ediff-mode-map ()
    "Add d to the keymap for ediff -- which copies both to the result buffer."
    (when (null quiescent-starting-up)
      (define-key ediff-mode-map "d" 'ediff-copy-both-to-C)))

  (add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map)
#+END_SRC

** Helm Mode
Helm mode used to be called Anything.el because it allowed one to
perform actions of any kind on any thing.  I imagine that it's name
changed because it's also a bit like being at the helm of a
complicated and powerful ship.

The basic idea of helm is that you are presented with a list of things
which have originated from some context.  e.g. a list of files in the
current directory.  Given that list, you may narrow it using multiple
out of order regular expressions.  Each regular expression reduces the
number of matches from the previous set.

You can search through the content of the items in the list (for
example if the items were files then grep the files) as well to
perform further narrowing.  Once you're happy with your list you can
select an item or mark multiple items and select an action to act on
your selection.

I want my helm to load in the current buffer instead of in the other
buffer (which is the default.) I also want helm to keep track of
recent files in helm minibuffer.  I found the other options I've
configured for helm in an [[https://tuhdo.github.io/helm-intro.html][introduction to helm]].

Before we can configure helm we need to load the package.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref helm :lexical t
  (defun quiescent-helm-grep-do-git-grep (arg)
    "Git grep with helm from the root of the project."
    (interactive "P")
    (let ((default-directory (locate-dominating-file default-directory ".git")))
      (helm-grep-do-git-grep arg)))

  (eval-when-compile
    (require 'cl-macs))

  (use-package helm
      :straight t
      :demand t
      :custom
      (helm-split-window-in-side-p           t)
      (helm-move-to-line-cycle-in-source     t)
      (helm-ff-search-library-in-sexp        t)
      (helm-scroll-amount                    8)
      (helm-ff-file-name-history-use-recentf t)
      (helm-grep-input-idle-delay            0.02)
      (helm-input-idle-delay                 0)
      (helm-grep-git-grep-command            "git --no-pager grep -n%cH --color=always --full-name -e %p -- %f ':!*package-lock.json' ':!*yarn.lock'")
      :config (progn
                (eval-and-compile
                  (add-to-list 'load-path "~/.emacs.d/lisp/helm-rg"))
                (require 'helm-rg)
                (require 'helm-config)
                (helm-mode 1)
                (define-key helm-grep-mode-map (kbd "C-c C-p") #'wgrep-change-to-wgrep-mode)
                (require 'helm-adaptive)
                (helm-adaptive-mode t)
                (global-set-key (kbd "M-y")       #'helm-show-kill-ring)
                (global-set-key (kbd "M-i")       #'helm-semantic-or-imenu)
                (global-set-key (kbd "C-x C-f")   #'helm-find-files)
                (global-set-key (kbd "C-x b")     #'helm-buffers-list)
                (global-set-key (kbd "M-x")       #'helm-M-x)
                (if (eq system-type 'windows-nt)
                    (global-set-key (kbd "C-S-f")     #'helm-rg)
                    (global-set-key (kbd "C-S-f")     #'quiescent-helm-grep-do-git-grep))
                (if (eq system-type 'windows-nt)
                    (global-set-key (kbd "C-c p s g") #'helm-rg)
                    (global-set-key (kbd "C-c p s g") #'quiescent-helm-grep-do-git-grep))
                (global-set-key (kbd "C-h C-f")   #'helm-recentf))
      :init (with-eval-after-load "helm"
              (helm-mode 1)))
#+END_SRC

** Shell
Sneakypeet is a developer who I met while working at Entelect.  I
convinced him to start using Emacs by using it to do a presentation at
the Clojure meetup.  He wanted to create a collection of shells for a
project using directories for those shells and by running some basic
command when you get there.  He sent me some Emacs Lisp to look at.
I've ammended it and included it below.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref sneaky-shells :lexical t
  (defun sneaky-execute-in-current-shell (cmd)
    "Execute CMD in the current shell."
    (progn
      (insert cmd)
      (comint-send-input)))

  (defun sneaky-prep-shell-for-command (shell-name &optional dir)
    "Create a shell buffer with the name SHELL-NAME or switch to it and interrupt jobs.

  Ensure that the shell is running in DIR, if supplied."
    (progn
      (when (null (get-buffer shell-name))
        (let ((default-directory (or dir default-directory)))
          (shell shell-name)))
      (switch-to-buffer-other-window shell-name)
      (comint-interrupt-subjob)))

  (defun sneaky-run-shells (&rest shells)
    "Run each shell description in SHELLS.

  A shell should be a list of the form (SHELL-NAME DIR CMD)."
    (mapc (pcase-lambda (`(,shell-name ,dir ,cmd))
            (progn
              (sneaky-prep-shell-for-command shell-name dir)
              (sneaky-execute-in-current-shell cmd)))
          shells))
#+END_SRC

Here's an example usage which I'm using to test how well this works.

#+BEGIN_SRC emacs-lisp :tangle no :lexical t
  (sneaky-run-shells '("test-1" "~/" "echo worked!")
                     '("test-2" "C:/" "echo also worked!")
                     '("test-expac-in-windows" "~/.emacs.d/" "echo also worked!"))
#+END_SRC

I want my shells to have very small mode lines and fringes so that I
can fit as many of them as possible into my Emacs session at a time
without wasting space.  I'd like to also change the font and it's
height so that I make better use of space.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref shells-setup :lexical t
  (require 'cl-lib)

  (defun quiescent-nuke-fringe (&optional window)
    "Remove the fringes in WINDOW."
    (set-window-fringes window 0 0))

  
  ;; https://stackoverflow.com/questions/17628985/how-to-set-a-buffer-locally-face-attribute-for-a-particular-buffer#17630877

  ;; First create new face which is a copy of mode-line
  (copy-face 'mode-line 'quiescent-shell-like-mode-line)

  ;; Change what you want in this new face
  (set-face-attribute 'quiescent-shell-like-mode-line nil
                :height 0.8)

  (set-face-attribute 'quiescent-shell-like-mode-line nil
                 :box nil)

  ;; The function to use the new face
  (defun quiescent-set-shell-like-mode-line-face ()
    (set (make-local-variable 'mode-line) ; This is how to make it local
      'quiescent-shell-like-mode-line))

  

  (defun quiescent-setup-shell-like ()
    "Setup shell mode to my liking."
    (progn
      (quiescent-nuke-fringe)
      (quiescent-set-shell-like-mode-line-face)))

  (defun quiescent-in-a-mode (window modes)
    "Produce t if buffer in WINDOW is in mode contained in MODES."
    (cl-some (apply-partially #'quiescent-window-contains-buffer-in-mode window)
          modes))

  (defvar quiescent-kill-fringes-modes '(shell-mode compilation-mode eshell-mode)
    "The modes in which fringes should be killed.")

  (defun quiescent-setup-fringe-widths ()
    "Make the fringe width 0 in windows with certain modes active."
    (when (null quiescent-starting-up)
      (walk-windows (lambda (window)
                (when (quiescent-in-a-mode window quiescent-kill-fringes-modes)
               (quiescent-nuke-fringe window)))
              nil
              'visible)))

  (defun quiescent-window-contains-buffer-in-mode (window mode)
    "Produce t if WINDOW displays a buffer in mode MODE."
    (eq (buffer-local-value 'major-mode
                   (window-buffer window))
     mode))

  (add-hook 'buffer-list-update-hook #'quiescent-setup-fringe-widths)
#+END_SRC

I want any shell which I open with =M-x shell= to open to the
directory which I'm in right now.  The following achieves that by
feeding =cd default-directory RET= to the shell after it's up.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref shell-here :lexical t
  (defun quiescent-shell-here (call-shell &rest args)
    "Start shell with CALL-SHELL and ARGS.
  Then switch directory to where we called it from"
    (let ((target-directory default-directory))
      (apply call-shell args)
      (run-at-time 0.1 nil (lambda ()
                             (insert (format "cd %s" target-directory))
                             (comint-send-input)))))

  (advice-add #'shell :around #'quiescent-shell-here)
#+END_SRC

It's a good idea to run a continuous compilation buffer while
developing.  Sometimes there's not really a good way to get to the
compilation command or you want to switch in between compilation and a
shell so having a key bound in comint-mode is a pretty good idea.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref compilation-minor-mode-key :lexical t
  (define-key comint-mode-map (kbd "<f6>") #'compilation-minor-mode)
#+END_SRC

I call shell with the universal argument a whole lot.  How about
turning that into a key binding because life's too short to type out
shell that many times in a day!

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref unique-shell :lexical t
  (defun quiescent-unique-shell (name)
    "Create a new shell in this directory with a user specified NAME."
    (interactive "sShell name: ")
    (shell (format "*shell: %s*" name)))

  (global-set-key (kbd "<f5>") #'quiescent-unique-shell)
#+end_src

** eShell
Eshell is an extremely powerful shell which comes standard with
Emacs.  I liked an idea I read in the [[https://www.masteringemacs.org][Mastering Emacs]] book about
keeping the cursor at the start like "plan 9" shell used to do
(apparently) so I've done the same.  Basically the point stays with the
command when you execute it so that you can edit and redo the command
rapidly instead of using a history command or pasting the command
again and again.

The aforementioned optimisation and a host of others are included in
my =eshell.el=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eshell-setup :lexical t
  (require 'em-prompt)
  (require 'vc-git)

  (defconst quiescent-eshell-project-buffer-regexp "\*eshell.*\*"
    "A regular expression which matches project eshell buffer names.")

  (require 'eshell)

  (defun quiescent-eshell ()
    "Create split current window and make bottom half an eshell instance."
    (interactive)
    (if (or (string-equal (buffer-name) eshell-buffer-name)
            (string-match quiescent-eshell-project-buffer-regexp (buffer-name)))
        (delete-window)
      (quiescent-eshell-switch-to-and-change-dir)))

  (defun quiescent-eshell-smart-initialise ()
    "Initialise `eshell-smart'."
    (when (null quiescent-starting-up)
      (eshell-smart-initialize)))

  (use-package em-smart
    :chords ((",s" . quiescent-eshell))
    :config (progn
              (setq eshell-where-to-jump 'begin)
              (setq eshell-review-quick-commands nil)
              (setq eshell-smart-space-goes-to-end t)
              (add-hook 'eshell-mode-hook 'quiescent-eshell-smart-initialise)))

  ;; This is originally borrowed from Ben's journal, but has since been
  ;; heavily modified
  ;; http://www.blogbyben.com/2013/08/a-tiny-eshell-add-on-jump-to-shell.html
  (defun quiescent-eshell-switch-to-and-change-dir ()
    "Switch to eshell and make sure we're in the directory the current buffer is in."
    (interactive)
    (let ((dir default-directory))
      (let* ((root               (ignore-errors (project-root (project-current))))
             (eshell-buffer-name (if root (format "*eshell: %s*" root) "*popup-eshell*")))
        (eshell)
        (switch-to-prev-buffer)
        (switch-to-buffer-other-window eshell-buffer-name))
      (goto-char (point-max))
      (unless (eq dir default-directory)
        (cd dir)
        (eshell-send-input)
        (goto-char (point-max)))))

  ;; Cool prompt from: https://www.reddit.com/r/emacs/comments/6f0rkz/my_fancy_eshell_prompt/
  (lambda ()
    (concat
     (propertize "[" 'face `(:foreground "green"))
     (propertize (user-login-name) 'face `(:foreground "red"))
     (propertize "@" 'face `(:foreground "green"))
     (propertize (system-name) 'face `(:foreground "blue"))
     (propertize "][" 'face `(:foreground "green"))
     (propertize (format-time-string "%H:%M" (current-time)) 'face `(:foreground "yellow"))
     (propertize "][" 'face `(:foreground "green"))
     (propertize (concat (eshell/pwd)) 'face `(:foreground "white"))
     (propertize "]\n" 'face `(:foreground "green"))
     (propertize ">" 'face `(:foreground "green"))
     (propertize (if (= (user-uid) 0) " # " " $ ") 'face `(:foreground "green"))))

  ;; The following comes from the emacs wiki:
  ;; https://www.emacswiki.org/emacs/EshellPrompt
  (defmacro with-face (str &rest properties)
    "Propertise STR with PROPERTIES."
    `(propertize ,str 'face (list ,@properties)))

  (defun shk-eshell-prompt ()
    "A fancy eshell prompt function."
    (let ((header-bg "dark slate grey"))
      (concat
       (with-face (concat (eshell/pwd) " ") :background header-bg)
       (with-face (format-time-string "(%Y-%m-%d %H:%M) " (current-time)) :background header-bg :foreground "#888")
       (with-face
        (or (ignore-errors (format "(%s)" (car (vc-git-branches)))) "")
        :background header-bg)
       (with-face "\n" :background header-bg)
       (with-face user-login-name :foreground "#5180b3")
       "@"
       (with-face "localhost" :foreground "green")
       (if (= (user-uid) 0)
           (with-face " #" :foreground "red")
         " $")
       " ")))

  (defun quiescent-eshell-prompt ()
    "My eshell prompt.

  A combination of one from the wiki and one from reddit."
    (concat
     (with-face "["                                       :foreground "#b2d7ff")
     (with-face (user-login-name)                           :foreground "#5180b3")
     (with-face "@"                                         :foreground "light grey")
     (with-face (system-name)                               :foreground "green")
     (with-face "]["                                      :foreground "#b2d7ff")
     (with-face (format-time-string "%H:%M" (current-time)) :foreground "light grey")
     (with-face "]["                                      :foreground "#b2d7ff")
     (with-face (eshell/pwd)                                :foreground "light grey")
     (with-face "]["                                      :foreground "#b2d7ff")
     (with-face (or (car (vc-git-branches)) "unversioned")  :foreground "light grey")
     (with-face "]\n"                                       :foreground "#b2d7ff")
     (with-face "->"                                       :foreground "#b2d7ff")
     (with-face (if (= (user-uid) 0) " # " " $ ")           :foreground "light grey")))

  (setq eshell-prompt-function 'quiescent-eshell-prompt)
  (setq-default eshell-prompt-regexp "-> \\$ ")

  (defun eshell-next-prompt (n)
    "Move to end of Nth next prompt in the buffer.
  See `eshell-prompt-regexp'."
    (interactive "p")
    (progn
      (dotimes (_ (abs n))
        (if (> n 0)
            (re-search-forward eshell-prompt-regexp nil t nil)
          (re-search-backward eshell-prompt-regexp nil t nil)))
      (when (< n 0)
        (re-search-forward eshell-prompt-regexp nil t nil))))
#+END_SRC

I'd like eshell to be able to interpret errors in output as well.  So
I'm going to add a mode which hooks into redrawing the prompt and
finds errors in the output of the last command.

(This is very much a work in progress.)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eshell-compilation-minor-mode :lexical t
  (define-minor-mode quiescent-global-eshell-compilation-mode ()
      "Parse the output of eshell commands for known error formats."
      :init-value nil
      :lighter    nil
      :group      'quiescent-global-eshell-compilation-mode
      :global     t
      (if quiescent-global-eshell-compilation-mode
       (add-hook 'eshell-after-prompt-hook #'quiescent-eshell-compilation-parse-errors)
     (remove-hook 'eshell-after-prompt-hook #'quiescent-eshell-compilation-parse-errors)))

  (defun quiescent-eshell-compilation-find-last-region ()
    "Find the last compilation region from point."
    (save-excursion
      (goto-char (point-max))
      (cons (save-excursion
           (eshell-previous-prompt 1)
           (point))
         (point))))

  ;; This is very close.  I've got it parsing the output, but it's not
  ;; producing links to the errors correctly :( It uses all sorts of
  ;; internal state for that.
  (defun quiescent-eshell-compilation-parse-errors ()
    "Parse compilation errors in the last output of eshell."
    (pcase (quiescent-eshell-compilation-find-last-region)
      (`(,start . ,end) (let ((compilation-locs (make-hash-table :test #'equal)))
                 (compilation-parse-errors start end)))))
#+END_SRC

*** Company Eshell Auto-Suggest
I recently read a blog post in which someone used the [[Completion Setup][sort of
completion I use everywhere]] for your eShell history.  Since the blog
post it's become a package on Melpa(!)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eshell-company-autosuggest :lexical t
  (defun quiescent-setup-eshell-completion ()
    "Setup completion for the Emacs shell."
    (when (null quiescent-starting-up)
      (company-mode 1)
      (esh-autosuggest-mode 1)
      (setq company-backends '(esh-autosuggest company-capf company-files))
      (setq completion-at-point-functions '(comint-completion-at-point t))))

  (use-package esh-autosuggest
    :straight t
    :demand t
    :config (progn
              (define-key esh-autosuggest-active-map (kbd "s-'") #'company-complete)
              (define-key esh-autosuggest-active-map (kbd "C-'") #'company-complete-selection)
              (define-key esh-autosuggest-active-map (kbd "M-'") #'company-complete-selection)
              (define-key esh-autosuggest-active-map (kbd "C-.") #'company-select-next)
              (define-key esh-autosuggest-active-map (kbd "M-.") #'company-select-next)
              (define-key esh-autosuggest-active-map (kbd "C-,") #'company-select-previous)
              (define-key esh-autosuggest-active-map (kbd "M-,") #'company-select-previous)
              (with-eval-after-load "esh-mode"
                (define-key eshell-mode-map (kbd "<tab>") #'company-complete-common)))
    :hook ((eshell-mode . quiescent-setup-eshell-completion)))
#+END_SRC

The back end in eShell auto suggest doesn't consider all candidates,
which I find very irritating.  It also doesn't do any kind of fuzzy
matching on history elements.  I'm going to solve the first problem
now and the second problem at a later point in time.

(I think that merging history candidates with the CAPF for shells
would do the trick because of the new ='flex= method for completion.)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eshell-company-autosuggest-fix-candidates :lexical t
  (require 'em-hist)

  (defun prefix-intersection (xs ys)
    "Produce the intersection of XS with YS where x is in YS if x is a prefix of an element in YS."
    (let (result)
      (dolist (x xs result)
        (dolist (y ys result)
          (when (s-starts-with-p x y t)
            (push x result))))))

  (defun esh-autosuggest-candidates (prefix)
    "Select all history candidates with the prefix PREFIX."
    (let* ((history
            (mapcar #'split-string
             (delete-dups
              (mapcar (lambda (str)
                        (string-trim (substring-no-properties str)))
                      (ring-elements eshell-history-ring)))))
           (prefix-elements (split-string prefix))
           (prefix-elements-length (length prefix-elements)))
      (mapcar (lambda (tokens) (mapconcat #'identity tokens " "))
              (cl-remove-if (lambda (history-element)
                              (not (eq (length (prefix-intersection prefix-elements
                                                                    history-element))
                                   prefix-elements-length)))
                            history))))
#+END_SRC

** Project
Emacs now has a built in project convenience library/package/thing
(honestly I'm not sure what the best name is for sources which appear
in the Emacs project, but which aren't packages or modules.)  I'm
going to port the work I did for projectile two step search to project
find file.  I think that it'll be useful and I'd like to give it to a
colleague to help him improve his work flow.

*** Bindings for Project
In the interim it would seem that projectile is broken with the latest
Emacs (26) so I'm going to go ahead and bind project find file.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref project-find-file :lexical t
  (defun quiescent-find-file-in-project ()
    "Find file in the current project using helm."
    (interactive)
    (let ((completing-read-function #'helm--completing-read-default))
      (project-find-file)))

  (global-set-key (kbd "C-S-P") #'quiescent-find-file-in-project)
  (global-set-key (kbd "C-c p f") #'quiescent-find-file-in-project)
#+END_SRC

I'd like to find a project file in a split window.  I need both a
function and a binding for this.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref project-find-file-other-window :lexical t
  (defun quiescent-project-find-file-other-window ()
    "Find a project file in another window."
    (interactive)
    (let* ((project (project-current t))
           (dirs (project-roots project))
           (table (project-file-completion-table project dirs))
           (file (project--completing-read-strict
                  "Find file" table nil nil
                  (thing-at-point 'filename)))
           (buffer (find-file-noselect file)))
      (pop-to-buffer buffer)))

  (global-set-key (kbd "C-x 4 C-S-P") #'quiescent-project-find-file-other-window)
#+END_SRC

It's also a necessity that it uses VC rather than trying to use EDE;
because I hardly use EDE anywhere when I'm doing my development.  I'm
going to put this setting and other general settings here.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref project-settings :lexical t
  (setq project-find-functions (list #'project-try-vc))
#+END_SRC

** Etags
Emacs has good support for using tags files to find stuff.  I've been
using it more and more.  It is approximate, but with some diligence it
can be incredibly powerful as a means of accelerating searching etc.

*** Searching for a Tag
Etags includes the means to do an interactive search for a tag.  I
want to be able to use this more conveniently, so I'm going to bind it
to =s-s=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref etags-tag-search :lexical t
  (require 'thingatpt)

  (defun quiescent-etag-isearch (point)
    "Search for a tag in the current project.

  Default the search to the symbol at POINT."
    (interactive "d")
    (let* ((default-symbol (thing-at-point 'symbol t))
           (search-term    (completing-read "Search term: "
                                            (list default-symbol)
                                            nil
                                            nil
                                            default-symbol)))
      (tags-search search-term)))

  (global-set-key (kbd "s-s") #'quiescent-etag-isearch)
#+END_SRC

*** Generating Tags for a Project
It's convenient to generate tags for the project which you're in on
either a timer or when a file changes.  The timer approach is the
simplest and I'm going to start there.  Later I'll make other
improvements to the idea.

(I think that project scoped variables were added to project recently.
I should take a look at using that feature in the
`project-command-at-interval' library.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref project-command-at-interval :lexical t
  (eval-and-compile
    (add-to-list 'load-path "~/.emacs.d/lisp/project-command-at-interval/"))

  (require 'project-command-at-interval)
#+END_SRC

** Goto Chg
EMACS provides a feature known as the mark ring (there are many other
rings as well) which allows one to jump between the points which were
marked in the local buffer and across buffer boundaries.  What this
doesn't necessarily track is the last place where an edit was
made.

What I used to do to get to the last place that I edited would be to
undo a change and have the buffer jump to that point.  This sucks,
because I need to make an edit and then undo twice to jump back to the
correct point on the edit ring.  Instead of doing that I've installed a
package called goto-chg, which provides a change history.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref goto-chg :lexical t
  (use-package goto-chg
    :straight t
    :config (progn
              (bind-chord "'," 'goto-last-change)
              (bind-chord ",." 'goto-last-change-reverse)))
#+END_SRC

** GREP
Grep is possibly the most ubiquitous search tool available in any Unix
like environment.  It's flexibility and power make it a favourite of
many programmers.

*** VC Git Grep
It turns out that I can call grep via git and that emacs has a
interface to it.  The advantage of this is that I can grep and get
results which ignore non-version controlled files.  This will greatly
speed up grep and also give me more relevant hits.

I'm replacing the old binding I had for =rgrep= in place for this
purpose and I'm going to make a modification to it that it doesn't ask
for the directory and just uses `vc-dir'.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref vc-git-grep :lexical t
  (defun quiescent-vc-git-grep (regexp &optional files)
    "Search for REGEXP in the current project using grep.

  Ignores files which aren't version controlled.

  Optionally you may specify a glob pattern for the typo of file to
  search through."
    ;; This comes from the definition of `vc-git-grep'
    (interactive
     (progn
       (grep-compute-defaults)
       (cond
        ((equal current-prefix-arg '(16))
         (list (read-from-minibuffer "Run: " "git grep"
                                     nil nil 'grep-history)
               nil))
        (t (let* ((regexp (grep-read-regexp))
                  (files (grep-read-files regexp)))
             (list regexp files))))))
    (vc-git-grep regexp files (vc-git-root default-directory)))

  (global-set-key (kbd "C-c C-r") #'quiescent-vc-git-grep)
#+END_SRC

** IDUTILS
I've been wanting a way to search through large bases of text very
quickly since I started working on gigantic projects (~10K+ files).
Searching that many files takes tools like grep far too long and the
solution has to be that the files must instead be indexed.  IDUTILS
provides indexing and searching of that index.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref idutils :lexical t
  (eval-and-compile
    (add-to-list 'load-path "~/.emacs.d/idutils/")
    (require 'idutils))
#+END_SRC

** Backup File
Emacs has a great feature for recovering work when it could be lost.
It backs up files which you edit.  By default it'll backup a file,
with a copy of that file in the same directory, when you open it for
the first time.  This isn't nearly as aggressive as I'd like it to be.
It turns out that you can get Emacs to make multiple backups and also
to put them into a different directory where all of your work is safe
and backed up.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref backup-files :lexical t
  (make-variable-buffer-local 'create-lockfiles)

  (setq backup-directory-alist `(("." . "~/.saves")))

  (setq backup-by-copying t)

  (setq delete-old-versions t
        kept-new-versions 8
        kept-old-versions 4
        version-control t)

  (setq vc-make-backup-files t)
#+END_SRC

** GTags
GNU Global is a tagging program which creates a binary database across
an entire project.  I'm interested in trying it to test how well it
works with Scala.  It turns out that it's pretty good.  I've needed to
compile it from source with support for Universal Ctags and also
configure Universal Ctags in order to get acceptable results.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref gtags :lexical t
  (defun quiescent-enable-ggtags-mode ()
    "Enable ggtags mode."
    (ggtags-mode 1))

  (defun quiescent-remove-ggtags-xref-backend ()
    "Remove the ggtags completion mechanism from the `company-backends'."
    (remove-hook 'xref-backend-functions #'ggtags--xref-backend t))

  (defvar install-ggtags
    (lambda ()
      `(use-package ggtags
      :straight t
      :config (progn
             (define-key ggtags-mode-map (kbd "M-.") nil)
             (define-key ggtags-mode-map (kbd "C-c M-.") #'ggtags-find-tag-dwim)
             (define-key ggtags-mode-map (kbd "C-c M-?") #'ggtags-find-reference))
      ;; Note that the order here is important
      :hook ((scala-mode . quiescent-remove-ggtags-xref-backend)
          (scala-mode . quiescent-enable-ggtags-mode))))
    "The code to call to install ggtags when we start my Emacs rather than when we compile it.")

  (eval (funcall install-ggtags))
#+END_SRC

** Smartscan Mode
Something I often do is search for the thing at point.  Mickey at
[[https://www.masteringemacs.org][Mastering Emacs]] wrote a package to cycle through occurrences of symbol
at point.  It's so simple and yet insanely useful for jumping between
usages and searching logs among other things.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref smartscan :lexical t
  (use-package smartscan
    :straight t
    :demand t
    :hook ((org-mode . quiescent-smartscan-enable))
    :config (progn
              (defun quiescent-smartscan-enable ()
                "Enable smartscan."
                (when (and (null quiescent-starting-up)
                           (boundp 'smartscan-mode))
                  (smartscan-mode 1)))
              (define-key smartscan-map (kbd "M-n") 'smartscan-symbol-go-forward)
              (define-key smartscan-map (kbd "M-p") 'smartscan-symbol-go-backward)
              (setq smartscan-symbol-selector "symbol")))

  (defun quiescent-disable-smartscan ()
    "Disable smartscan mode."
    (when (and (null quiescent-starting-up)
               (boundp 'smartscan-mode))
      (smartscan-mode -1)))

  (add-hook 'eshell-mode-hook #'quiescent-disable-smartscan)
#+END_SRC

** Writable Grep
It's possible to edit a Grep buffer and apply those changes to the
lines in the original files.  This is so incredibly cool that I just
had to add it to my configuration.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref wgrep :lexical t
  (use-package wgrep
   :straight t)

  (use-package wgrep-ag
   :straight t)
#+END_SRC

** Read Only Regions
Sometimes you can lose control of a region of text which has become
read only.  I've decided to add interactive functions for adding and
removing the read only property on such text so that I can manually
intervene.  Inspired by [[https://stackoverflow.com/questions/20023363/emacs-remove-region-read-only][this post]].

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref read-only :lexical t
  (defun quiescent-set-region-read-only (beg end)
    "Set the buffer region [BEG, END) to read-only."
    (interactive "r")
    (add-text-properties beg end '(read-only t)))

  (defun quiescent-unset-region-read-only (beg end)
    "Remove read only from the buffer region [BEG, END)."
    (interactive "r")
    (let ((inhibit-read-only t))
      (add-text-properties beg end '(read-only nil))))
#+END_SRC

** Go Up
I recently saw a friend of mine use a keybinding in his terminal:
C-<UP>.  It moved a directory upwards.  I thought to myself.  I need
this in my life.  So here it begins... and if it becomes useful, it
will grow.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref go-up :lexical t
  (defun quiescent-one-directory-above-current ()
    "Produce the directory one above the current one."
    (file-name-directory (substring default-directory
                                    0
                                    (- (length default-directory)
                                       1))))

  (defun quiescent-go-up ()
    "Do the thing which would most logically be considered going up in the current mode."
    (interactive)
    (cond
     ((eq major-mode 'eshell-mode)
      (progn
        (setq default-directory
              (quiescent-one-directory-above-current))
        (eshell-send-input)))
     ((eq major-mode 'dired-mode)
      (dired-up-directory))
     ((eq major-mode 'shell-mode)
      (progn
        (insert "cd ..")
        (comint-send-input)))
     ((eq major-mode 'minibuffer-inactive-mode)
      ;; TODO: Handle home dir
      (progn
        (end-of-line)
        (backward-char)
        (when (looking-at "/")
          (delete-char 1))
        (ignore-errors (forward-char))
        (zap-to-char -1 ?/)
        (insert "/")))
     (t
      (find-file default-directory))))

  (global-set-key (kbd "C-^") #'quiescent-go-up)
#+END_SRC

Update: it grew beyond shells.  I can now hit =C-^= from just about
anywhere and it does a context sensitive "up" command.

** Numbering Adjustment
I often find myself performing edits which are really just adjusting
numbering on a list.  For instance I could find myself needing to add
an element to the middle of a numbered list and need to increment all
subsequent elements.  The most common operation is to increment (or
decrement) the number at point -- as below:

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref increment-number-at-point :lexical t
  (defun quiescent-increment-number-at-point ()
    "Increment the number at point.

  Assume that we're in a number.  Behaviour is undefined when we're
  outside of one."
    (interactive)
    (save-excursion
      (progn
        (skip-chars-backward "0123456789")
        (let ((start-of-number (point))
              end-of-number
              number)
          (when (not (looking-at "[0-9]+"))
            (error "No number to increment"))
          (replace-match (format "%s" (1+ (string-to-number (match-string 0)))))))))

  (defun quiescent-decrement-number-at-point ()
    "Increment the number at point.

  Assume that we're in a number.  Behaviour is undefined when we're
  outside of one."
    (interactive)
    (save-excursion
      (progn
        (skip-chars-backward "0123456789")
        (let ((start-of-number (point))
              end-of-number
              number)
          (when (not (looking-at "[0-9]+"))
            (error "No number to increment"))
          (replace-match (format "%s" (1- (string-to-number (match-string 0)))))))))
#+END_SRC

** Recent Files
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref recentf :exports none :lexical t
  <<recentf-mode>>
  <<recentf-ext>>
#+END_SRC
There is a facility in Emacs to keep a list of the files which have
been recently visited (in the order of how recently they were
visited).  IDO has a mode where these files are listed along side the
buffers you could switch to.  I want this! :P The following sets up
recentf mode, next I'll need to add them to the list of buffers to
switch to when doing switch buffer.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref recentf-mode :lexical t
  (require 'recentf)

  (defun quiescent-open-recent-file ()
    "Open a recent file use recentf for completion."
    (interactive)
    (find-file (completing-read "Recent file: " recentf-list)))

  (use-package recentf
    :init (recentf-mode t)
    :defer 10
    :config (progn
              (setq recentf-max-saved-items 50)
              (run-at-time nil (* 5 60) 'recentf-save-list)))
#+END_SRC

The following library adds support for dired and also makes it so that
when you switch buffer it becomes the most recent file.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref recentf-ext :lexical t
  (use-package recentf-ext
    :straight t)
#+END_SRC

Now for the magical part.  I'm going to combine buffer switch with
recentf so that I can switch to any buffer including recently open
ones with switch buffer... Here goes.  On second thought I shouldn't
need this because I switch to active buffers with =C-z= so I can use a
different binding for recent files/buffers.

** Ignore That Case
I often want a Regex to work while ignoring the case of the phrases
which it matches.  This code will replace the alpha-only word at point
with a case insensitive version of it.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref ignore-regex-case :lexical t
  (defun quiescent-ignore-regex-case ()
    "Replace the alpha-only word at point with a case insensitive version."
    (interactive)
    (progn
      (search-backward-regexp "[a-zA-Z]*[^a-zA-Z]")
      (forward-char)
      (save-match-data
        (save-excursion
          (search-forward-regexp "\\([a-zA-Z]*\\)[^a-zA-Z]?"))
        (replace-match (mapconcat (lambda (char) (list ?\[ char (upcase char) ?\]))
                                  (downcase (match-string 0)) "")))))
#+END_SRC

** Keyboard Macros
So the default binding either involves <F3>, which is a bit out of the
way, or =C-x (= which is a bit too much for something that you'd want
to do quickly.  I'm going for =S-(= now instead.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref keyboard-macros :lexical t
  (global-set-key (kbd "s-(") #'kmacro-start-macro-or-insert-counter)
  (global-set-key (kbd "s-)") #'kmacro-end-or-call-macro)
#+END_SRC

** String Replacement
There are some common editing tasks which have no keybinding.
Replacing a string is one of those.  I've put that somewhere
convenient, but I'm not sure that it's actually the best way of doing
the task anymore.

When I wrote this keybinding I was unaware of the features in
=isearch= which allow one to perform similar actions in a more
interactive mode.  You can now =C-s <m a t c h i n g l e t t e r s>
M-% <r e p l a c e m e n t>= and get an interactive replacement.  If
you're satisfied with the replacement you can hit bang to make it so
across the board.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref string-replacement :lexical t
(global-set-key (kbd "C-c r") 'replace-string)
#+END_SRC

** Moving In Aligned Text
I often find myself in a large buffer with an data laid out with one
entry per line.  If I'm in a profile report (which I'm in a lot
recently) then this data is usually a call graph and it's organised
one entry per line and indented to indicate the level of the call
graph.

Navigating this data can be frustrating, because you might want to see
the other entries at the same level as the one which you're on at the
moment.  What fallows is an implementation of a simple next/previous
entry at same level command so that it's easier to work with this
data.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref aligned-navigation :lexical t
  (defmacro aligned-searcher (backward)
    "Create an aligned move function.

  A non-nil BACKWARD argument means move backwards."
    `(let* ((indentation (buffer-substring (line-beginning-position)
                                           (save-excursion
                                             (move-beginning-of-line nil)
                                             (while (looking-at "[[:space:]]") (forward-char))
                                             (point))))
            (number-of-lines-to-move (- (save-excursion
                                          (,(if backward `search-backward-regexp `search-forward-regexp)
                                            (format "^%s[^[:space:]]" indentation) nil nil)
                                          (line-number-at-pos))
                                        (line-number-at-pos)))
            line-move-visual)
       (push-mark nil t)
       (line-move number-of-lines-to-move)))

  (defun aligned-next ()
    "Move forward to the next line which is at the same indentation."
    (interactive)
    (aligned-searcher nil))

  (defun aligned-previous ()
    "Move back to the next line which is at the same indentation."
    (interactive)
    (aligned-searcher t))

  (defvar aligned-movement-mode-map
      (let ((keymap (make-sparse-keymap)))
        (define-key keymap (kbd "s-n") #'aligned-next)
        (define-key keymap (kbd "s-p") #'aligned-previous)
        keymap)
    "The keymap for `aligned-search-mode'")

  (define-minor-mode aligned-movement-mode ()
    "Enable bindings locally for aligned record movement.

  Aligned record movement means moving backwards and forwards by
  lines which have the same leved of indentation.  This is very
  useful when inspecting call graphs and other similarly formatted
  buffers.  (might be useful in programming languages like
  Python!)

  Forward is S-n.
  Backward is S-p."
    :init-value nil
    :ligther nil
    :global nil)
#+END_SRC

** Semantic
Semantic is a parser generator and set of tools for use with Emacs
which enables Emacs to understand more about the programming language
which the code represents.  This information is used to improve how
buffers are navigated, completions made etc.  There's been some recent
discussion on the mailing list about making parsing a first class
feature.  I'm interested in whether this can be achieved with
semantic.

This will be the latest in a long list of attempts to use semantic as
part of my Emacs.  This time though, I have a much better
understanding of everything that it uses and how it comes together,
and I have a plan to make it work for large projects.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref semantic :lexical t
  (require 'semantic)
  (require 'semantic/db)
  (require 'semantic/db-find)
  (require 'semantic/ia)

  (setq semantic-default-submodes
     '(global-semantic-highlight-func-mode
       global-semantic-decoration-mode
       global-semantic-stickyfunc-mode
       global-semantic-idle-scheduler-mode
       global-semantic-idle-local-symbol-highlight-mode
       global-semantic-highlight-edits-mode
       global-semantic-show-unmatched-syntax-mode))

  (defvar quiescent-fix-elisp-parser
    (lambda ()
      `(when (and (fboundp 'eval-and-compile)
           (fboundp 'eval-when-compile)
           (fboundp 'cl-defmethod)
           (fboundp 'cl-defgeneric)
           (fboundp 'cl-deftype))
     (progn
       (semantic-elisp-setup-form-parser
        (lambda (form start end)
          (semantic-tag-new-function
           (symbol-name (nth 2 form))
           nil
           '("form" "start" "end")
           :form-parser t))
        eval-and-compile
        eval-when-compile)
       (semantic-elisp-setup-form-parser
        (lambda (form start end)
          (let* ((a2 (nth 2 form))
              (a3 (nth 3 form))
              (args (if (listp a2) a2 a3))
              (doc (nth (if (listp a2) 3 4) form)))
            (semantic-tag-new-function
          (symbol-name (nth 1 form))
          nil
          (if (listp (car args))
              (cons (symbol-name (caar args))
                 (semantic-elisp-desymbolify-args (cdr args)))
            (semantic-elisp-desymbolify-args (cdr args)))
          :parent (if (listp (car args)) (symbol-name (cadr (car args))) nil)
          :documentation (semantic-elisp-do-doc doc))))
        cl-defmethod
        cl-defgeneric)
       (semantic-elisp-setup-form-parser
        (lambda (form start end)
          (let ((doc (semantic-elisp-form-to-doc-string (nth 3 form))))
            (semantic-tag-new-variable
          (symbol-name (nth 1 form))
          nil
          (nth 2 form)
          :user-visible-flag (and doc
                         (> (length doc) 0)
                         (= (aref doc 0) ?*))
          :constant-flag (eq (car form) 'defconst)
          :documentation (semantic-elisp-do-doc doc))))
        cl-deftype))))
    "Fix eLisp parser in eLisp modes.

  I add stuff here as I find that it can't be parsed by semantic.")

  (defun quiescent-fix-elisp-parser ()
    "Fix the elisp parser for semantic."
    (when (null quiescent-starting-up)
      (eval (funcall quiescent-fix-elisp-parser))))

  (add-hook 'emacs-lisp-mode-hook #'quiescent-fix-elisp-parser)

  (require 'semantic/bovine/el)

  (semantic-mode t)
#+END_SRC

** Separedit
I discovered a mode which enables one to edit commends and strings in
a mode which is more appropriate for editing text.  The idea being
that you can benefit from all of the facilities of editing text while
being in some programming language buffer, by temporarily editing the
content elsewhere.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref separedit :lexical t
  (use-package separedit
    :straight t
    :config
    (progn
      (define-key prog-mode-map (kbd "C-c '") #'separedit)
      (setq separedit-default-mode 'org-mode)))
#+END_SRC

** Thought Stack
   Sometimes, I'll be writing or searching through code and then I'll
   realise that there's something else to take care of.  Usually I
   like to complete my current train of thought before returning to
   finish the other related thought.  It can be hard or disconcerting
   to keep track of all of these related thoughts, so I'm going to
   write a mode to take care of that for me.

   #+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref thought-stack :lexical t
     (define-minor-mode thought-stack-mode
       "Keep track of small related tasks.

     e.g. when refactoring code, you might change the signature of a
     function and then discover that the function is used in a related
     way somewhere else.  If you want to switch train of thought, then
     it might be a good idea to note what you were doing, or you could
     note the related task before continuing.

     This mode makes that easier by maintaing a stack of things to
     take care of when you're done with what you're doing."
       :init-value nil
       :lighter    nil
       :keymap     (make-sparse-keymap)
       :global     t
       :group      'thought-stack)

     (defvar thought-stack '()
       "The stack of related thoughts.")

     (require 'cl-lib)

     (defun thought-stack-window-points ()
       "Produce an map of the windows to their current points."
       (cl-loop
        with positions = (make-hash-table :test #'equal)
        for window being the windows
        do (puthash window (window-point window) positions)
        finally (return positions)))

     (defun thought-stack-restore-window-points (window-points)
       "Restore the points that were set in WINDOW-POINTS."
       (cl-loop
        for window being the hash-keys of window-points
        do (set-window-point window (gethash window window-points))))

     (defun thought-stack-push (concept)
       "Push CONCEPT onto the thought stack.

     Saves the window configuration that's active now."
       (interactive "sPush: ")
       (push (list concept
                   (current-window-configuration)
                   (thought-stack-window-points))
             thought-stack))

     (defun thought-stack-pop ()
       "Pop the current concept from the thought stack.

     Returns the window configuration to what it was when you pushed
     the thought."
       (interactive)
       (let ((thought (pop thought-stack)))
         (if thought
             (progn
               (set-window-configuration (cadr thought))
               (thought-stack-restore-window-points (caddr thought))
               (message (format "You were doing: %s" (car thought))))
           (error "No thoughts left"))))

     (defun thought-stack-view ()
       "Print the thought stack in a temporary buffer."
       (interactive)
       (progn
         (switch-to-buffer-other-window (get-buffer-create "*thought-stack*"))
         (special-mode)
         (read-only-mode -1)
         (delete-region (point-min) (point-max))
         (mapc (lambda (item) (insert (format " * %s\n" (car item)))) thought-stack)
         (read-only-mode 1)))

     (define-key thought-stack-mode-map (kbd "s-[") #'thought-stack-push)
     (define-key thought-stack-mode-map (kbd "s-]") #'thought-stack-pop)
     (define-key thought-stack-mode-map (kbd "s-?") #'thought-stack-view)

     (thought-stack-mode)
   #+end_src

** Dumb Jump
Sometimes, sophisticated methods of finding the definition of a
function or symbol don't cut it.  This is especially true when you're
writing a DSL but also true when the resources required to find the
definition of a function are just too heavy.  Enter "Dump Jump"!

#+begin_src  emacs-lisp :tangle no :noweb yes :noweb-ref dumb-jump :lexical t
  (use-package dumb-jump
    :straight t
    :init
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    (setq xref-show-definitions-function #'xref-show-definitions-completing-read))
#+end_src

** Variable Name Translations
Ever found a bunch of variables named in capital snake case, kebab
case, pascal case or snake case and you want it in the other format?
These functions serve that purpose.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref variable-translations :lexical t
  (require 'subr-x)
  (require 'cl-lib)

  (defun capitalise (word)
    "Produce a properly capitalised WORD."
    (format "%s%s"
            (upcase (substring word 0 1))
            (substring word 1)))

  (defun quiescent-capital-snake-case-to-camel-case ()
    "Convert the variable name at POINT into camel case from capital snake case."
    (interactive)
    (save-excursion
      (let* ((bounds (bounds-of-thing-at-point 'symbol))
             (thing  (thing-at-point 'symbol))
             (words  (thread-last
                       (split-string thing "_")
                       (mapcar (lambda (word) (downcase word))))))
        (goto-char (car bounds))
        (delete-region (car bounds) (cdr bounds))
        (insert (apply #'cl-concatenate
                       'string
                       (car words)
                       (mapcar #'capitalise (cdr words)))))))
#+end_src

* Modifications to Specific Programming Language Modes
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref modifications-to-specific-programming-languages :exports none :lexical t
  <<julia>>
  <<yaml>>
  <<groovy>>
  <<c-mode>>
  <<plantuml>>
  <<fsharp>>
  <<graphviz-dot>>
  <<web-mode>>
  <<sass>>
  <<rjsx>>
  <<powershell>>
  <<haskell>>
  <<cython>>
  <<nxml-mode>>
  <<sql>>
  <<maven>>
  <<javascript>>
  <<typescript>>
  <<rust>>
  <<rustic>>
  <<slime>>
  <<qlot>>
  <<cider>>
  <<emacs-lisp>>
  <<scala>>
  <<dockerfile>>
  <<kotlin>>
  <<terraform>>
  <<emacs-jupyter>>
  <<pyvenv>>
  <<python-completion>>
  <<c-plus-plus>>
  <<c>>
  <<racket>>
  <<ado-mode>>
  <<enh-ruby>>
  <<ess>>
  <<swift>>
  <<c-sharp>>
#+END_SRC
It's been said that a programming language can't call itself a
"programming language" until it has a major mode in EMACS.  What
follows is the way that I've customised the major modes for the
languages which I use.

** Julia
I need a mode to write Julia because I had a pair programming session
with a friend from a Clojure meetup.  We ended up spending a lot of
time looking at our editors instead of solving the problem which was a
lot of fun and very informative.  One of the core ideas which Josh
expressed is that the Vim philosophy of orthogonal text objects and
the things you can do with them should be formally specified so that
it can be implemented in different editors.  I really liked some of
the ideas I saw, for instance:
 - Repeat command: a sort of auto macro-ing mode which records what
   you did when you were in edit mode and then lets you repeat it.  I
   could have a similar thing in Emacs by just remembering the last
   commands and then repeating them with a key-binding.  To make this
   really useful I would have to consider how to start and stop
   recording in a natural way so that you don't have insane stretches
   being recorded.
 - The other idea which I'd like to steal is frecency, something
   supported very well by FASD which is a command line tool for
   jumping about.  The idea in Emacs would be to super charge =M-x=
   and =C-x C-f= so that they presented more likely options first.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref julia :lexical t
  (use-package julia-mode
    :straight t)
#+END_SRC

We ended up implemented the sieve of Eratosthenes and it was
surprisingly compact and fast.  Here it is:

#+BEGIN_SRC julia :lexical t :tangle no
  function seive(max)
      i = 2
      xs = [1:max;]
      while (i < sqrt(max))
          if (xs[i] != 0)
              for j in [i+i:i:max;]
                  xs[j] = false
              end
          end
          i += 1
      end
      return filter(x -> x != 0, xs)
  end

  print(seive(100))
#+END_SRC

** YAML
Yet Another Markdown Language is a highly structured, and human
readable, format for serialising data to.  It's less of a markdown
format and more of a rigid file specification usually used for
configuration and settings.  I've gotten a mode for editing it
predominantly for font lock features so that it's easier to see
mistakes.  It tends to do a better job of indenting text as well
though because you can cycle through the indentation options rather
than having your editor dumbly continue to tab the text further and
further from it's correct position.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref yaml :lexical t
  (use-package yaml-mode
      :straight t)
#+END_SRC

** Groovy
Groovy is a dynamically typed language based on Java.  It's pretty
cool, and it can be used to specify pipelines for Jenkins.  I'm adding
it mainly for the highlighting, but it says that it's based on CC mode
so it should have a bunch of features which I'm as of yet unaware of.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref groovy :lexical t
  (use-package groovy-mode
      :straight t)
#+END_SRC

** C Mode
Emacs comes with a c mode which provides basic editing support for
several c style languages including integration with the debugger and
syntax highlighting.  I have configured mine to use the Linux style of
code indentation.

NOTE: I've included pre-save hooks in here which I should consider
extending to support more languages.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref c-mode :lexical t
  (require 'cc-mode)

  (setq c-default-style "linux"
     c-basic-offset  4)
  (setq auto-mode-alist (cons '("\.ino$" . c-mode) auto-mode-alist))

  (defconst quiescent-clean-buffer-max-size 100000
    "The maximum size of buffer to consider for cleaning when saving.")

  (defmacro quiescent-when-small-enough (body)
    "Execute BODY when the buffer is small enough to."
    `(let ((min (point-min))
        (max (point-max)))
       (when (< (- max min) quiescent-clean-buffer-max-size)
      ,body)))

  ;; Credit for the indent whole buffer part:
  ;; https://www.emacswiki.org/emacs/ReformatBuffer
  (defun quiescent-indent-whole-buffer ()
    "Indent the current buffer.

  Doesn't do anything if the buffer is too big."
    (save-excursion
      (quiescent-when-small-enough
       (indent-region (point-min) (point-max) nil))))

  (defun quiescent-whitespace-cleanup ()
    "Whitespace cleanup the current buffer.

  Doesn't do anything if the buffer is too big."
    (save-excursion
      (quiescent-when-small-enough
       (indent-region (point-min) (point-max) nil))))

  (defun quiescent-untabify-whole-buffer ()
    "Untabify the current buffer.

  Doesn't do anything if the buffer is too big."
    (save-excursion
      (quiescent-when-small-enough
       (untabify (point-min) (point-max)))))

  (defun quiescent-prog-save-hook ()
    "Things to do when I save cc files."
    (when (null quiescent-starting-up)
      (progn
     (add-hook 'before-save-hook
            #'quiescent-whitespace-cleanup nil 'local)
     (add-hook 'before-save-hook
            #'quiescent-indent-whole-buffer nil 'local)
     (add-hook 'before-save-hook
            #'quiescent-untabify-whole-buffer nil 'local))))

  (add-hook 'c++-mode-hook        #'quiescent-prog-save-hook)
  (add-hook 'c-mode-hook          #'quiescent-prog-save-hook)
  (add-hook 'java-mode-hook       #'quiescent-prog-save-hook)
  (add-hook 'emacs-lisp-mode-hook #'quiescent-prog-save-hook)
  (add-hook 'javascript-mode-hook #'quiescent-prog-save-hook)

#+END_SRC

** Plant UML
I use plant UML to draw diagrams for documentation among other things.
I've decided to add this mode for it's ability to syntax highlight,
but I might find other features as I use it more.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref plantuml :lexical t
  (use-package plantuml-mode
    :straight t)
#+END_SRC

** fSharp mode
I've started writing fsharp code for a tech accelerator project.  I
don't have any real config for the mode.  I know that it's fairly
powerful and can do completion and syntax checking.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref fsharp :lexical t
  (use-package fsharp-mode
      :straight t)
#+END_SRC

** Graphviz Dot Mode
Graphviz Dot is a language for drawing graphs with vector graphics.  I
wanted a mode to do syntax highlighting.  This is it.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref graphviz-dot :lexical t
  (use-package graphviz-dot-mode
      :straight t)
#+END_SRC

** Web Mode
Web mode is an editing mode for html which comes with better font lock
and tag completion mechanisms than the built in mode.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref web-mode :lexical t
  (require 'sgml-mode)

  (setq sgml-quick-keys 'close)

  (use-package company-web
    :straight t
    :config (add-hook 'html-mode-hook #'quiescent-setup-company-web-completion))

  (defun quiescent-setup-company-web-completion ()
    "Set the company backends for web completion."
    (when (null quiescent-starting-up)
      (setq-local company-backends '(company-web-html company-dabbrev))))

  (use-package web-mode
    :straight t
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (with-eval-after-load "js2-mode"
      (progn
        (require 'js2-mode)
        (define-key web-mode-map (kbd "C-c C-'") #'quiescent-indirectly-edit-script-dwim)
        (define-key js2-mode-map (kbd "C-c C-'") #'quiescent-indirectly-edit-script-dwim))))

  (use-package emmet-mode
    :straight t
    :config
    (add-hook 'web-mode-hook #'emmet-mode))

  (use-package mmm-mode
    :straight t
    :config
    (setq mmm-global-mode 'maybe)
    (mmm-add-mode-ext-class 'html-mode "\\.html\\'" 'html-js)
    (mmm-add-mode-ext-class 'html-mode "\\.html\\'" 'embedded-css))

  (defun quiescent-indirectly-edit-script (point)
    "Indirectly edit the script that POINT is in.

  Produce an error if it isn't in a script."
    (interactive "p")
    (let* ((script-start (save-excursion
                           (web-mode-element-parent)
                           (when (looking-at "<script")
                             (web-mode-tag-end))))
           (script-end (save-excursion
                         (when script-start
                           (goto-char script-start)
                           (web-mode-element-end)
                           (backward-char)
                           (web-mode-tag-beginning)
                           (point)))))
      (when (and script-start script-end)
        (narrow-to-region script-start script-end)
        (js2-mode))))

  (defun quiescent-indirectly-edit-script-dwim (point)
    "Either start or end an indirect edit session for script that POINT is in."
    (interactive "p")
    (if (buffer-narrowed-p)
        (progn
          (widen)
          (web-mode 1))
      (quiescent-indirectly-edit-script point)))

  (with-eval-after-load 'flycheck
    (flycheck-add-mode 'html-tidy 'web-mode))
#+END_SRC

** SASS
SASS is a language which is supposed to provide all of CSS plus a few
more features.  There is no built in support for Emacs so I'm going to
go ahead and get a mode for it.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref sass :lexical t
  (use-package sass-mode
   :straight t)
#+END_SRC

** RJSX Mode
A colleague of mine recently showed me a mode which extends js2-mode
for JSX files.  I'm going to make it the official mode for editing JSX
because my weird combination of web, built in and other modes for
editing them isn't all that graceful.

NOTE: I need to checkout the new stuff in Emacs27 for highlighting and
correctly indenting JSX.  It sounds pretty awesome from what I've read
on the mailing list.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref rjsx :lexical t
  (use-package rjsx-mode
   :straight t
   :init (add-to-list 'auto-mode-alist '("\\.jsx\\'" . rjsx-mode))
   :config (add-hook 'rjsx-mode-hook #'quiescent-disable-semantic-mode))

  (defun quiescent-disable-semantic-mode ()
    "Disable semantic mode locally."
    (semantic-mode -1))

  (defun quiescent-electric-layout-create-tag (n &optional killflag)
    "When N is 1 and KILLFLAG nil, if next char is ?< then insert a newline."
    (when (and (eq n 1)
               (null killflag)
               (looking-at-p "<"))
      (progn
        (save-excursion
          (newline 2)
          (indent-for-tab-command))
        (forward-line 1)
        (indent-for-tab-command))))

  (advice-add #'rjsx-delete-creates-full-tag :after #'quiescent-electric-layout-create-tag)
#+END_SRC

** Powershell Mode
Sometimes I have to use Powershell to do stuff in Windows because the
bash port isn't complete enough.  Powershell mode gives basic
highlighting and indentation along with some other features I just
don't use.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref powershell :lexical t
  (use-package powershell
      :straight t
      :config (add-to-list 'auto-mode-alist '("\\.ps1$" . powershell-mode)))
#+END_SRC

** Haskell Mode
Emacs doesn't have a Haskell editing mode built in.  There is one
available though, and it provides documentation, indentation and
highlighting.  Combine with Flycheck and it's nearly a fully fledged
dev environment -- pretty awesome.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref haskell :lexical t
  (defun quiescent-turn-on-haskell-doc-mode ()
    "Activate `haskell-doc-mode'."
    (when (null quiescent-starting-up)
      (turn-on-haskell-doc-mode)))

  (use-package haskell-mode
    :straight t
    :config (add-hook 'haskell-mode-hook #'quiescent-turn-on-haskell-doc-mode))

  (require 'haskell-interactive-mode)
  (require 'haskell-process)
  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)

  (custom-set-variables
    '(haskell-process-suggest-remove-import-lines t)
    '(haskell-process-auto-import-loaded-modules t)
    '(haskell-process-log t))

  (custom-set-variables '(haskell-tags-on-save t))

  (custom-set-variables
    '(haskell-process-type 'stack-ghci))

  (with-eval-after-load "interactive-haskell-mode"
    (define-key interactive-haskell-mode-map (kbd "M-n") #'haskell-goto-next-error)
    (define-key interactive-haskell-mode-map (kbd "M-p") #'haskell-goto-prev-error))

  (defun quiescent-disable-flycheck-mode ()
    "Disable flycheck mode."
    (when (null quiescent-starting-up)
      (flycheck-mode -1)))

  (add-hook 'haskell-debug-mode-hook #'quiescent-disable-flycheck-mode)
  (add-hook 'haskell-debug-mode-hook #'quiescent-disable-flyspell-mode)

  ;; Haskell mode
  (use-package async
    :straight t)
  (defun haskell-mode-generate-tags (&optional and-then-find-this-tag)
    "Generate tags using Hasktags.  This is synchronous function.

  If optional AND-THEN-FIND-THIS-TAG argument is present it is used
  with function `xref-find-definitions' after new table was
  generated."
    (interactive)
    (let* ((dir (haskell-cabal--find-tags-dir))
           (command (haskell-cabal--compose-hasktags-command dir)))
      (if (not command)
          (error "Unable to compose hasktags command")
        (async-start-process "hasktags" "*hask-tags-buffer*" (split-string command)))))
#+END_SRC

*** Dependencies of Haskell Modifications
    Cabal packages to install:
    - hslint
    - hindent
    - happy
    - hasktags
    - stylish-haskell
    - present (didn't work though :/ and needed for :present in terminal)

    A lot of this comes from:
    https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

** Cython Mode
Cython is a mode for writing Cython code -- for when Python aint fast
enough.  It provides indentation and syntax highlighting.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref cython :lexical t
  (use-package cython-mode
      :load-path "~/.emacs.d/cython")
#+END_SRC

** nXML
nXML mode is used to edit XML.  It's a pretty solid mode, but even so
I've built up a few modifications to it to improve the experience.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref nxml-mode :lexical t
  (require 'nxml-mode)

  (defun pretty-print-xml (begin end)
    "Pretty format XML markup in [`BEGIN', `END'] region.

  You need to have `nxml-mode'
  http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
  this.  The function inserts linebreaks to separate tags that have
  nothing but whitespace between them.  It then indents the markup
  by using nxml's indentation rules."
    (interactive "r")
    (save-excursion
      (nxml-mode)
      (goto-char begin)
      (while (search-forward-regexp "\>[ \\t]*\<" nil t)
     (backward-char) (insert "\n"))
      (indent-region begin end))
    (message "Ah, much better!"))

  (defun quiescent-disable-flyspell-mode ()
    "Disable flyspell mode."
    (when (null quiescent-starting-up)
      (flyspell-mode -1)))

  (defun quiescent-disable-flycheck-mode ()
    "Disable flycheck mode."
    (when (null quiescent-starting-up)
      (flycheck-mode -1)))

  (defun quiescent-indent-four-if-pom-or-context ()
    "Setup indentation to use four spaces in nxml if I'm looking at a pom or context file."
    (when (null quiescent-starting-up)
      (let ((name (buffer-name)))
     (when (or (string-match-p "context.*xml" name)
            (string-match-p "pom.xml"      name))
       (setq nxml-child-indent 4
          nxml-attribute-indent 4)))))

  (add-hook 'nxml-mode-hook #'quiescent-disable-flyspell-mode)
  (add-hook 'nxml-mode-hook #'quiescent-disable-flycheck-mode)
  (add-hook 'nxml-mode-hook #'quiescent-indent-four-if-pom-or-context)

  (push "~/.emacs.d/schemas.xml" rng-schema-locating-files)

  (setq nxml-slash-auto-complete-flag t)
#+END_SRC

** SQL Mode
Emacs doesn't come with a built in means of formatting SQL so I looked
around and found SQL indent.  Going to see if it fits the bill.

Update: it turns out that this package isn't all that great at
indenting sql code.  I've left it's ref out of the section tangle and
kept the definition here for reference.

Deprecated because it doesn't actually work all that well...
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref sql-indent :lexical t
  (use-package sql-indent
    :straight t
    :config (eval-after-load "sql"
              '(load-library "sql-indent")))
#+END_SRC

I have an idea for completion in SQL buffers:
 - Define a fixed list of completion options
 - Use thing at point to do a fuzzy search through the list of items
 - Present those as candidates to completion-ui

In my system specific tasks file I can define lists of symbols
relevant for completion in each DB I connect to, as a buffer local
variable, to override the definition of the list here.

NOTE: This worked quite well in a job where I edited a lot of SQL.
These days I don't.  I've since learned that `pcomplete', a built in
package, was designed for this exact task.  I should try using it next
time that I need something like this.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref sql :lexical t
  (defvar quiescent-sql-completion-candidates '("SELECT" "FROM" "WHERE" "ORDER" "GROUP" "BY" "UPDATE" "DELETE")
    "A variable list of candidates to complete a sql symbol from.")

  (defvar quiescent-sql-original-completion-candidates '("SELECT" "FROM" "WHERE" "ORDER" "GROUP" "BY" "UPDATE" "DELETE")
    "A fixed list of candidates to complete a sql symbol from.")

  (require 'thingatpt)
  (require 'sql)

  (use-package flx
    :straight t)
  (use-package flx-ido
    :straight t)

  (defun quiescent-fuzzy-completion (prefix completions)
    "Complete the given PREFIX using a fixed list of COMPLETIONS.

  Part of this is ripped out of the implementation of flx's
  ido matching and sorting.  See `flx-ido-match-internal'."
    (let ((flex-result (flx-flex-match prefix completions)))
      (if (< (length flex-result) flx-ido-threshold)
          (let* ((matches (cl-loop for item in flex-result
                                   for string = (ido-name item)
                                   for score = (flx-score string prefix flx-file-cache)
                                   if score
                                   collect (cons item score)
                                   into matches
                                   finally return matches)))
            (mapcar 'car (delete-consecutive-dups
                          (sort matches
                                (lambda (x y) (> (cadr x) (cadr y))))
                          t)))
        (mapcar 'car  flex-result))))

  (defun quiescent-sql-completion ()
    "Complete PREFIX fuzzily using a fixed list of completions.

  The fixed list is read from a variable:
  `quiescent-sql-completion-candidates', which ought to be set when
  connecting to a given database."
    (let* ((prefix        (thing-at-point           'symbol))
           (prefix-bounds (bounds-of-thing-at-point 'symbol))
           (candidates
            (if (looking-at "^")
                (quiescent-fuzzy-completion prefix quiescent-sql-original-completion-candidates)
              (quiescent-fuzzy-completion prefix quiescent-sql-completion-candidates))))
      (if (null candidates)
          (progn (message "No candidates for completion found")
                 nil)
        (list (car prefix-bounds) (cdr prefix-bounds) candidates))))

  (defun quiescent-register-sql-completion ()
    "Register the sql completion function as a completion method in this buffer."
    (when (null quiescent-starting-up)
      (progn
        (setq completion-at-point-functions (list #'quiescent-sql-completion))
        (setq completion-ignore-case        t))))

  (add-hook 'sql-mode-hook #'quiescent-register-sql-completion)

  (defun quiescent-describe-table-at-point ()
    "Desicribe the table at point."
    (interactive)
    (sql-send-string (format "DESCRIBE %s;"
                             (thing-at-point 'symbol t))))

  (define-key sql-mode-map (kbd "C-c C-d")
    #'quiescent-describe-table-at-point)
#+END_SRC

** Maven
When editing Java; I often need to jump to the nearest maven file up
from here (including while in a maven file.) The following snippet is
designed to allow me to do that.

If I'm writing a spring boot app in the future then the following
commands can be used to run it with profiles (local and default)
and to debug it with those same profiles respectively:
- mvn-backend spring-boot:run -Drun.profiles=local,default
- mvn-backend spring-boot:run -Drun.profiles=local,default -Drun.jvmArguments="-agentlib:jdwp=transport=dt_shmem,address=jdbconn,server=y,suspend=n"

Attaching to a debug process in java is done as follows:
 - jdb -attach <server>


#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref maven :lexical t
  (defun quiescent-nearest-pom-up ()
    "Goto the nearest pom file updwards from the current directory."
    (interactive)
    (let* ((start-directory (if (equal (file-relative-name (buffer-file-name)
                                                           default-directory) "pom.xml")
                                (quiescent-up-directory default-directory)
                              default-directory))
           (pom-dir (locate-dominating-file start-directory "pom.xml")))
      (when (not pom-dir)
        (error "Pom not found"))
      (find-file (concat pom-dir "pom.xml"))))

  (require 'subr-x)

  (defun quiescent-up-directory (dir)
    "Produce the directory one up from DIR.

  Nil if root is supplied as DIR."
    (string-join (reverse (cddr (reverse (split-string dir "/")))) "/"))

  (defun quiescent-maven-compile-on-nearest-pom-up (mvn-command)
    "Find the nearest pom up from the current directory and run MVN-COMMAND."
    (interactive "sMaven command to run: ")
    (let ((starting-buffer (buffer-name)))
      (progn
        (quiescent-nearest-pom-up)
        (compile (format "mvn -f %s %s" (buffer-file-name) mvn-command))
        (switch-to-buffer starting-buffer))))
#+END_SRC

** Javascript
I've recently been writing some Javascript in order to prepare for a
dojo I'll be giving with two of my colleagues.  I've decided to enable
js2-mode and give that a bash.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref javascript :exports none :lexical t
  (use-package js2-mode
    :straight t
    :config (progn
              (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
              (add-to-list 'interpreter-mode-alist '("node" . js2-mode))
              (define-key js2-mode-map (kbd "<f5>") #'quiescent-start-node-with-this-file)
              (define-key js2-mode-map (kbd "<f6>") #'quiescent-start-mocha-with-this-file)
              (define-key js2-mode-map (kbd "<f7>") #'quiescent-start-jest-with-this-file)))

  (require 'flycheck)

  (flycheck-define-checker html-jshint
    "A JavaScript linter for html."
    :command ("jshint" "--extract=auto" "--reporter=checkstyle" source)
    :error-parser flycheck-parse-checkstyle
    :error-filter
    (lambda (errors)
      (flycheck-remove-error-file-names
       "stdin" (flycheck-dequalify-error-ids errors)))
    :modes (web-mode))

  (flycheck-add-next-checker 'html-tidy 'html-jshint)

  (add-to-list 'flycheck-checkers 'html-jshint t)

  ;; Courtesy: http://daniel-bush.blogspot.co.za/2014/12/emacs-flycheck-and-jshint-and-other.html
  (flycheck-define-checker javascript-jscs
    "A JavaScript style checker using jscs.

  See URL `https://www.npmjs.com/package/jscs'."
    :command ("jscs" "--reporter=checkstyle"
              (config-file "--config" flycheck-jscsrc)
              source)
    :error-parser flycheck-parse-checkstyle
    :modes (js-mode js2-mode js3-mode js-jsx-mode))

  (flycheck-def-config-file-var flycheck-jscsrc javascript-jscs ".jscsrc"
    :safe #'stringp)

  (add-to-list 'flycheck-checkers 'javascript-jscs t)
  (flycheck-add-next-checker 'javascript-jshint '(t . javascript-jscs))
  (flycheck-add-next-checker 'javascript-jshint '(t . javascript-eslint))

  (flycheck-add-mode 'javascript-jshint #'js-jsx-mode)

  (add-hook 'js2-mode-hook #'quiescent-select-jshint)
  (add-hook 'rjsx-mode-hook #'quiescent-select-eslint)

  (defun quiescent-select-eslint ()
    "Select EsLint as the linter in this buffer."
    (interactive)
    (when (null quiescent-starting-up)
      (flycheck-select-checker 'javascript-eslint)))

  ;; From https://emacs.stackexchange.com/questions/21205/flycheck-with-file-relative-eslint-executable
  (defun my/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint
            (and root
                 (expand-file-name (format "node_modules/.bin/eslint%s"
                                           (if (eq system-type 'windows-nt) ".cmd" ""))
                                   root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))

  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)

  (defun quiescent-select-jshint ()
    "Select JSHint as the linter in this buffer."
    (interactive)
    (when (and (null quiescent-starting-up)
               (not (eq flycheck-checker 'javascript-eslint))
               (not (eq major-mode 'rjsx-mode)))
      (flycheck-select-checker 'javascript-jshint)))

  (defconst quiescent-node-url-extracting-regexp "://.*127.0.0.1:\\([0-9]+\\)/\\(.*\\)"
    "A regular expression which can extract the port and path of node process.")

  (defconst quiescent-node-buffer-failed "failed"
    "A regular expression to match instances where the node buffer failed to start.")

  (defun quiescent-node-name-for-this-file ()
    "Compute the name of the node process buffer for this file."
    (format "*node-%s*" (buffer-name)))

  (defvar quiescent-node-used-ports '()
    "A list of the ports used to spin up indium interactive processes.

  TODO: derigester ports when the associated process dies.")

  (defun quiescent-random-node-port ()
    "Produce a random port for node to run on which isn't already in use."
    (let (result)
      (while (member (setq result (+ 8000 (random 1000)))
                     quiescent-node-used-ports))
      result))

  (defun quiescent-start-node-with-this-file ()
    "Start node in the current buffer with the debugger."
    (interactive)
    (quiescent--start-process-with-this-file "node"))

  (defun quiescent-start-mocha-with-this-file ()
    "Start mocha in the current buffer with the debugger.

  Requires that there exists file <project-root>/tests/.test.setup.js
  which does any necessary prep for the test."
    (interactive)
    (quiescent--start-process-with-this-file
     "mocha"
     (list "--inspect" (format "%stests/.test.setup.js"
                               (projectile-project-root)))))

  ;;(require 'quiescent/projectile)

  ;; Left these here because I think that they might be useful
  (defun quiescent-babel-process-name (buffer-name)
    "Produce a babel process name for BUFFER-NAME."
    (format "*babel-process-%s*" buffer-name))

  (defvar quiescent-use-babel-with-launched-files t
    "Whether files should first be translated before being debugged.")

  (defun quiescent-babel-translate-this-file ()
    "Translate this file and store it at `<file-name-sans-extension>.babel.js'.
  Produces the new file name."
    (let ((process-name    (quiescent-babel-process-name (buffer-name)))
          (babel-file-name (concat (file-name-sans-extension (buffer-file-name)) ".babel.js")))
      (start-process process-name process-name
                     "babel" "--preset" "es2015,react" (buffer-file-name) "-o" babel-file-name)
      babel-file-name))

  (defun quiescent-start-jest-with-this-file ()
    "Start jest in the current buffer with the debugger."
    (interactive)
    (quiescent--start-process-with-this-file
     "babel-node"
     (list "--harmony"
           "--inspect"
           (format "%snode_modules/jest/bin/jest.js"
                   (projectile-project-root))
           "--runInBand")))

  (defun quiescent--start-process-with-this-file (process &optional args)
    "Start PROCESS with `--inspect' on this buffer.

  Intention is for it to be used by indium mode.

  Supply the (optional) list of ARGS to that process."
    (let* ((node-process-name (quiescent-node-name-for-this-file))
           (random-port       (quiescent-random-node-port))
           (file-path         (buffer-file-name))
           port
           path)
      (progn
        (when (bufferp (get-buffer node-process-name))
          (with-current-buffer node-process-name (erase-buffer)))
        (apply
         #'start-process
         node-process-name
         node-process-name
         process
         (cons (format "--inspect-brk=%s" random-port)
               (reverse (cons file-path
                              (reverse args))))))
      (with-current-buffer node-process-name
        (let ((buffer-text (progn
                             (while (string= "" (buffer-string))
                               (sleep-for 0 100))
                             (buffer-string))))
          (when (string-match quiescent-node-buffer-failed buffer-text)
            (error "Couldn't start node process: %s" buffer-text))
          (string-match quiescent-node-url-extracting-regexp
                        buffer-text)
          (setq port (substring buffer-text (match-beginning 1) (match-end 1))
                path (substring buffer-text (match-beginning 2) (match-end 2)))))
      (indium-nodejs--connect "127.0.0.1"
                              port
                              path)))

  (defun quiescent-last-message ()
    "Produce the last message logged, as the last line in `*Messages*'."
    (with-current-buffer "*Messages*"
      (goto-char (point-max))
      (beginning-of-line)
      (forward-line -1)
      (buffer-substring (point) (progn (end-of-line)
                                       (point)))))

  (defun quiescent-overlay-of-fun (orig-fun &rest args)
    "Run ORIG-FUN with ARGS and create an overlay with it."
    (progn
      (apply orig-fun args)
      (sleep-for 0 100)
      (quiescent-haskell-result-overlay-at-point (quiescent-last-message))))

  (advice-add #'indium-eval-last-node :around #'quiescent-overlay-of-fun)

  ;; To start debugging, open the following URL in Chrome:
  ;;     chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/a8ef938b-045a-4098-b50e-e1a18cf415c7

  ;; (use-package indium
  ;;   :straight t)

  (defun quiescent-is-js2-mode ()
    "Produce t if this buffer is in `js2-mode'."
    (eq major-mode 'js2-mode))

  (defun quiescent-indium-interaction-mode ()
    "Activate `indium-interaction-mode'."
    (when (null quiescent-starting-up)
      (indium-interaction-mode 1)))

  (use-package js2-refactor
    :straight t)

  (defun quiescent-pluse-ignoring-args (&rest _)
    "Run `xref-pulse-momentarily' ignoring ARGS."
    (xref-pulse-momentarily))

  (advice-add #'js2-jump-to-definition :after #'quiescent-pluse-ignoring-args)

  (defun quiescent-xref-jump-when-point-doesnt-move (jump-fun &rest args)
    "Execute JUMP-FUN with ARGS, jump with xref if it didn't move."
    (let ((start (point)))
      (ignore-errors (apply jump-fun args))
      (when (eql start (point))
        (xref-find-definitions (thing-at-point 'symbol)))))

  (advice-add #'js2-jump-to-definition :around #'quiescent-xref-jump-when-point-doesnt-move)

  <<eslint-fix-mode>>
  <<fix-linting-at-point>>
  <<js2-highlight-var-at-point>>
  <<js2-highlight-var-at-point-fix-timer>>
  <<js2-mode-extras>>
  <<nodejs-repl>>
  <<js2-raise-variable>>
#+END_SRC

**** Eslint
I've found that it's useful to be able to include hooks to modes for
things like fixing linting and then remove them later.  This section
is dedicated to doing that sort of thing for Javascript.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eslint-fix-mode :lexical t
  (defvar quiescent-javascript-eslint-fix-modes '(js2-mode web-mode js-jsx-mode rjsx-mode)
    "The modes which should have eslint --fix run on their files.")

  (define-minor-mode quiescent-global-javascript-eslint-fix-mode ()
    "Run esLint with fix on Javascript and JSX files when saving them."
    :init-value nil
    :lighter    nil
    :group      'quiescent-eslint-fix
    :global     t
    (if quiescent-global-javascript-eslint-fix-mode
     (mapc (lambda (mode)
            (add-hook (intern (concat (symbol-name mode) "-hook"))
                   #'quiescent-fix-eslint-add-hook))
          quiescent-javascript-eslint-fix-modes)
      (mapc (lambda (mode)
          (remove-hook (intern (concat (symbol-name mode) "-hook"))
                    #'quiescent-fix-eslint-add-hook))
           quiescent-javascript-eslint-fix-modes)))

  (defun quiescent-fix-eslint-add-hook ()
    "Add the after save hook to the current mode."
    (add-hook 'after-save-hook #'quiescent-javascript-eslint-this-file))

  (defun quiescent-fix-eslint-remove ()
    "Remove the after save hook from the current mode."
    (remove-hook 'after-save-hook #'quiescent-javascript-eslint-this-file))

  (defvar quiescent-buffer-to-revert nil
    "The buffer which ought to be reverted when the process returns.")

  (defun quiescent-javascript-eslint-this-file ()
    "Eslint this file with fix turned on."
    (interactive)
    (when (member major-mode quiescent-javascript-eslint-fix-modes)
      (setq quiescent-buffer-to-revert (current-buffer))
      (async-start-process (format "eslint-%s" (buffer-file-name))
                  "eslint"
                  (lambda (process) (auto-revert-buffers))
                  "--fix"
                  (buffer-file-name))))
#+END_SRC

Note that the following packages might be required globally to make
this work:

 - eslint
 - eslint-plugin-flowtype
 - eslint-plugin-react
 - eslint-plugin-prettier
 - eslint-config-react
 - eslint-config-prettier
 - babel-eslint
 - eslint-config-google
 - prettier

Here's an alternative idea to fixing linting errors.  Provide
something which parses the output of a Linter via Flycheck and applies
the recommendation to the code at point.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref fix-linting-at-point :lexical t
  ;; TODO account for multiple checkers reporting on the current line
  (defun quiescent-correct-linting-errors-at-point (point)
    "Correct linting errors reported by Eslint via Flycheck at POINT."
    (interactive "d")
    (let* ((error-overlay (car (flycheck-overlays-at (point))))
       (lint-suggestion (when error-overlay
                  (flycheck-error-message
                   (overlay-get error-overlay
                        'flycheck-error)))))
      (if lint-suggestion
       (pcase (split-string lint-suggestion)
     (`("Delete" ,to-delete) (quiescent-correct-linting-delete to-delete
                                   error-overlay))
     (`("Replace" ,string "with" ,replacement)
      (quiescent-correct-linting-replace string replacement error-overlay))
     (`("Insert" ,string)
      (quiescent-correct-linting-insert string error-overlay)))
       (fill-paragraph))))

  (defun quiescent-correct-linting-insert (string error-overlay)
    "Insert STRING at the start of ERROR-OVERLAY."
    (save-excursion
      (goto-char (overlay-start error-overlay))
      (insert (quiescent-eslint-string-to-regexp
           (quiescent-get-string-out-of-eslint-quotes string)))))

  (defun quiescent-correct-linting-compute-search-string (raw-search-string)
    "Escape RAW-SEARCH-STRING from Eslint so that it can be searched for."
    (regexp-quote
     (quiescent-get-string-out-of-eslint-quotes
      (quiescent-eslint-string-to-regexp raw-search-string))))

  (defun quiescent-correct-linting-replace (string replacement error-overlay)
    "Replace STRING with REPLACEMENT at the start of ERROR-OVERLAY."
    (let ((regexp-to-delete (quiescent-correct-linting-compute-search-string string)))
      (save-excursion
    (goto-char (overlay-start error-overlay))
    (when (re-search-forward regexp-to-delete
                 nil
                 t)
      (replace-match (quiescent-get-string-out-of-eslint-quotes
              (quiescent-eslint-string-to-regexp replacement)))))))

  (defun quiescent-get-string-out-of-eslint-quotes (eslint-string-in-quotes)
    "Get the ESLINT-STRING-IN-QUOTES from out of it's `` quotes."
    (substring eslint-string-in-quotes 1 (1- (length eslint-string-in-quotes))))

  (defun quiescent-eslint-string-to-regexp (eslint-string)
    "Transform ESLINT-STRING to a regexp."
    (replace-regexp-in-string "" "\n"
                  (replace-regexp-in-string "" " "
                            eslint-string)))

  (defun quiescent-correct-linting-delete (to-delete error-overlay)
    "Find and delete the string TO-DELETE in the bounds of ERROR-OVERLAY."
    (let ((regexp-to-delete (quiescent-correct-linting-compute-search-string to-delete)))
      (save-excursion
    (goto-char (overlay-start error-overlay))
    (when (re-search-forward regexp-to-delete
                 nil
                 t)
      (replace-match "")))))

  (require 'js2-mode)
  (define-key js2-mode-map (kbd "M-q") #'quiescent-correct-linting-errors-at-point)
#+END_SRC

**** JS2 Highlight Vars
I recently found a package which will highlight the variable at point
using the js2-mode ast... want.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref js2-highlight-var-at-point :lexical t
  (use-package js2-highlight-vars
   :straight t)

  (defun quiescent-activate-js2-highlight-vars-mode ()
    "Activate `js2-highlight-vars'."
    (when (null quiescent-starting-up)
      (js2-highlight-vars-mode 1)))

  (add-hook #'js2-mode-hook #'quiescent-activate-js2-highlight-vars-mode)
#+END_SRC

Unfortunately one cannot configure the length of the timer.  I want it
to be instant.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref js2-highlight-var-at-point-fix-timer :lexical t
  (defun js2-highlight-vars-post-command-hook ()
    (ignore-errors
      (let* ((overlays (overlays-at (point)))
          (ovl (and overlays
                 (catch 'found
                (dolist (ovl overlays)
                  (when (overlay-get ovl 'js2-highlight-vars)
                    (throw 'found ovl)))
                nil))))
     (if (and ovl
           (string= js2--highlight-vars-current-token-name
                 (buffer-substring (overlay-start ovl)
                             (overlay-end ovl))))
         (setq js2--highlight-vars-current-token (overlay-start ovl))
       (js2--unhighlight-vars)
       (when js2--highlight-vars-post-command-timer
         (cancel-timer js2--highlight-vars-post-command-timer))
       (setq js2--highlight-vars-post-command-timer
          (run-with-timer 0 nil 'js2--do-highlight-vars))))))
#+END_SRC

I've recently discovered Nicolas Peton's blog: [[https://emacs.cafe/][Emacs Cafe]].  It has a
nice series on setting up Emacs for Javascript editing.  I'm going to
incorporate some of the stuff which he talks about.

**** JS2 Imenu
The first feature which I'm kicking myself for not seeing at first is
Imenu support for js2-mode symbols!  This doesn't really need any
further introduction and it's easy to configure.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref js2-mode-extras :lexical t
  (defun quiescent-activate-js2-imenu-extras ()
    "Activate `js2-imenu-extras-mode'."
    (when (null quiescent-starting-up)
      (js2-imenu-extras-mode 1)))

  (add-hook 'js2-mode-hook #'quiescent-activate-js2-imenu-extras)
#+END_SRC

Out of the box JS2 imenu support doesn't add constants to the menu.
This sucks if you declare a lot of your functions as constants --
which I do when I'm using Ramda.  The key to solving this is to add a
case for handling =var= declarations (and maybe =let= and =const= too)
e.g. =js2-var-decl-node-p= to =js2-imene-walk-ast=.  I don't have the
time right now but I'm pretty sure that I'll be taking a look soon.

**** NodeJS Repl
Sometimes you want to just work with a REPL for some Node code that
you're hacking away it.  In those instances full-blown installations
like Indium provide too much functionality and require that you setup
a whole project.  In those instances I prefer to just connect to a
REPL and run some commands.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref nodejs-repl :lexical t
  (use-package nodejs-repl
    :straight t)

  (defun quiescent-activate-node-js-repl ()
    "Activate a node-js repl for this session."
    (interactive)
    (progn
      (define-key js2-mode-map (kbd "C-x C-e") #'nodejs-repl-send-last-expression)
      (define-key js2-mode-map (kbd "C-c C-j") #'nodejs-repl-send-line)
      (define-key js2-mode-map (kbd "C-c C-r") #'nodejs-repl-send-region)
      (define-key js2-mode-map (kbd "C-c C-l") #'nodejs-repl-load-file)
      (define-key js2-mode-map (kbd "C-c C-z") #'nodejs-repl-switch-to-repl)))
#+end_src

**** Raise Variable
I write a lot of Lisp and one of the things that you can do very
easily is move expressions up one node in the syntax tree.  i.e. you
can put the point on a list, and then raise that list to replace the
list which it was in, with that list.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref js2-raise-variable :lexical t
  (defun quiescent-js2-raise-variable (p)
    "Raise the variable at point, P."
    (interactive "d")
    (let* ((node          (ignore-errors (js2-node-at-point)))
           (node-start    (and node (js2-node-abs-pos node)))
           (up-list-point (save-excursion (ignore-errors (backward-up-list)) (point)))
           (expression    (if (or (null node) (= up-list-point node-start))
                              (let ((simple-node (js2-node-at-point)))
                                (buffer-substring (js2-node-abs-pos simple-node)
                                                  (js2-node-abs-end simple-node)))
                              (buffer-substring node-start (js2-node-abs-end node)))))
      (if (eq 'rjsx-node (type-of (js2-node-at-point)))
          (goto-char (js2-node-abs-pos (js2-node-parent (js2-node-at-point))))
          (backward-up-list))
      (let ((node-to-replace (js2-node-at-point)))
        (if (eq (type-of node-to-replace) 'js2-import-clause-node)
            (kill-sexp)
          (delete-region (js2-node-abs-pos node-to-replace) (js2-node-abs-end node-to-replace))))
      (save-excursion (insert expression))))

  (define-key js2-highlight-vars-local-keymap (kbd "M-r") nil)
  (define-key js2-mode-map (kbd "M-r") #'quiescent-js2-raise-variable)
#+end_src

** Typescript
A project at work is using type script for tests.  I've started this
configuration section to help out with that.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref typescript :lexical t
  <<tide>>

  (use-package typescript-mode
      :straight t
      :config (add-to-list 'auto-mode-alist '("\\.tsx$" . typescript-mode)))
#+END_SRC

I've recently found the TIDE package for developing in typescript and
since the project which I'm about to start working on requires a
working typescript setup I thought that I'd go ahead and set it up.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref tide :lexical t
  (use-package tide
    :straight t
    :init
    (progn
      (add-hook 'js2-mode-hook        #'quiescent-setup-tide-mode)
      (add-hook 'js2-jsx-mode-hook    #'quiescent-setup-tide-mode)
      (add-hook 'typescript-mode-hook #'quiescent-setup-tide-mode)))

  (defun quiescent-tide-jump-to-definition (&optional arg)
    "Jump to the definition of the symbol at point.

  If pointed at an abstract member-declaration, will proceed to look for
  implementations.  When invoked with a prefix arg, jump to the type definition.

  Copied from tide's sources with the addition of calling
  js2-mode's find definition and then xref when tide fails."
    (interactive "P")
    (let ((cb (lambda (response)
                (if (and (tide-response-success-p response)
                         (null (plist-get response :message)))
                    (condition-case err
                        (js2-jump-to-definition)
                      (error (xref-find-definitions (thing-at-point 'symbol))))
                  (tide-on-response-success response
                      (-when-let (filespan (car (plist-get response :body)))
                        ;; if we're still at the same location...
                        ;; maybe we're a abstract member which has implementations?
                        (if (and (not arg)
                                 (tide-filespan-is-current-location-p filespan))
                            (tide-jump-to-implementation)
                          (tide-jump-to-filespan filespan tide-jump-to-definition-reuse-window))))))))
      (if arg
          (tide-command:typeDefinition cb)
        (tide-command:definition cb))))

  (defun quiescent-setup-tide-mode ()
    "Setup TIDE mode."
    (when (null quiescent-starting-up)
      (progn
        (tide-setup)
        (define-key tide-mode-map (kbd "M-?") 'tide-references)
        (tide-hl-identifier-mode +1)
        (setq-local company-backends '(company-tide company-files))
        (advice-add #'tide-jump-to-definition :before  #'xref-push-marker-stack)
        (define-key tide-mode-map (kbd "M-.") #'quiescent-tide-jump-to-definition)
        (setq xref-backend-functions '(dumb-jump-xref-activate etags--xref-backend)))))
#+END_SRC

** Rust
I went to a meet up on 12/04/2016 for functional programming -- it was
really cool, an awesome bunch of people.  We covered the rust
programming language which has officially blown my mind.  The main
thing that I find interesting is that it has no garbage collection and
still manages to be memory safe.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref rust :lexical t
  (use-package rust-mode
      :straight t)
#+END_SRC

There's an entire setup for a development environment which integrates
Rust more tightly with the tools in Emacs.  It's called Rustic and I'm
going to give it a bash.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref rustic :lexical t
  (use-package rustic
    :straight t
    :config
    (progn
      (setq rustic-lsp-server 'rust-analyzer)
      (setq lsp-rust-analyzer-server-command '("~/.cargo/bin/rust-analyzer"))
      (setq rustic-lsp-client 'eglot)
      (remove-hook 'rustic-mode-hook #'flycheck-mode)))

  (defun rustic-mode--find-project-root (directory)
    "Produce the root of Rust project containing DIRECTORY."
    (let ((rustic-root (locate-dominating-file directory "cargo.toml")))
      (when rustic-root
        (cons 'transient rustic-root))))

  (require 'project)

  (add-hook 'project-find-functions #'rustic-mode--find-project-root)
#+END_SRC

** Common Lisp
SLIME is a mode for Emacs written in Common Lisp, Scheme and Emacs
Lisp which provides an interactive server to enhance the development
of Lisp inside of Emacs.  It's an incredibly powerful tool which
provides interactive development and debugging and has been the
inspiration for many modes after it.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref slime :lexical t
  (use-package slime-company
      :straight t)

  (defun quiescent-setup-slime-completion ()
    "Setup company for slime."
    (when (null quiescent-starting-up)
      (company-mode 1)
      (setq-local company-backends '(company-capf company-slime))
      (setq-local completion-at-point-functions '(quiescent-slime-completion-at-point))))

  (defun quiescent-slime-completion-at-point ()
    "A completion at point function for slime.

  Based on `slime-expand-abbreviations-and-complete' from
  `slime-c-p-c'."
    (let* ((end (move-marker (make-marker) (slime-symbol-end-pos)))
           (beg (move-marker (make-marker) (slime-symbol-start-pos)))
           (prefix (buffer-substring-no-properties beg end)))
      (pcase (slime-contextual-completions beg end)
        (`(,completions . ,_) `(,beg ,end ,completions . (:exclusive 'no))))))

  (require 'cl-lib)

  (defun quiescent-close-slime-help ()
    "Close the help window."
    (interactive)
    (let ((original-window (selected-window)))
      (cl-loop
      for window being the windows
      when (equal "*slime-description*" (buffer-name (window-buffer window)))
        do (select-window window)
           (call-interactively #'quit-window))
      (select-window original-window)))

  (defun quiescent-slime-company-doc-mode (&rest _)
    "Fontify the current buffer as a Slime documentation buffer."
    (run-at-time 0.1 nil
                 (lambda () (let ((original-window (selected-window)))
                              (cl-loop
                               for window being the windows
                               when (equal "*slime-description*" (buffer-name (window-buffer window)))
                               do (select-window window)
                               (slime-company-doc-mode))
                              (select-window original-window)))))

  ;; These forms need to be protected from compilation so that they use
  ;; dynamic scoping for the repl history file.
  (eval `(defun quiescent-slime-load-history (&optional path)
           "Read the Slime history file interactively or from PATH."
           (interactive (list (let ((slime-repl-history-file (concatenate 'string
                                                                          default-directory
                                                                          ".slime-history.eld")))
                                (slime-repl-read-history-filename))))
           (slime-repl-load-history path)))

  (eval `(defun quiescent-slime-save-history (&optional path)
           "Read the Slime history file interactively or from PATH."
           (interactive (list (let ((slime-repl-history-file (concatenate 'string
                                                                          default-directory
                                                                          ".slime-history.eld")))
                                (slime-repl-read-history-filename))))
           (slime-repl-save-history path)))

  (require 'xref)

  (defun quiescent-xref-push-marker-stack (&rest _)
    "Push the current point onto the xref marker stack."
    (xref-push-marker-stack))

  (defun quiescent-slime-edit-definition (name)
    "Find the definition of NAME, falling back to xref when we fail."
    (interactive (list (or (and (not current-prefix-arg)
                                (slime-symbol-at-point))
                           (slime-read-symbol-name "Edit Definition of: "))))
    (condition-case nil
        (slime-edit-definition name)
      (error (xref-find-definitions name))))

  (use-package slime
    :straight t
    :config
    (progn
      (define-key slime-mode-map (kbd "s-q") #'quiescent-close-slime-help)
      (define-key slime-mode-map (kbd "M-.") #'quiescent-slime-edit-definition)
      (advice-add 'slime-describe-symbol :after #'quiescent-slime-company-doc-mode)
      (advice-add 'slime-describe-function :after #'quiescent-slime-company-doc-mode)
      (advice-add 'slime-edit-definition :before #'quiescent-xref-push-marker-stack)

      (require 'slime-repl)
      (define-key slime-repl-mode-map (kbd "C-x C-s") #'quiescent-slime-save-history)
      (define-key slime-repl-mode-map (kbd "C-x C-f") #'quiescent-slime-load-history)
      (define-key slime-repl-mode-map (kbd "C-M-r")   #'slime-repl-previous-matching-input)
      (add-hook 'slime-mode-hook      #'quiescent-setup-slime-completion)
      (add-hook 'slime-repl-mode-hook #'quiescent-setup-slime-completion))
    :init (progn (setq inferior-lisp-program "sbcl")
                 (setq auto-mode-alist (cons '("\.cl$" . common-lisp-mode) auto-mode-alist))))

  (defun quiescent-setup-slime ()
    "Setup slime."
    (slime-setup '(slime-fancy slime-company slime-c-p-c slime-highlight-edits slime-xref-browser slime-asdf)))

  (add-hook 'after-init-hook #'quiescent-setup-slime)

  (defun quiescent-slime-restart-advice (f &rest args)
    "Wrap call to Slime restart function, F, with ARGS saving window state."
    (save-window-excursion
      (apply f args)))

  (advice-add #'slime-restart-sentinel :around #'quiescent-slime-restart-advice)
#+END_SRC

Instructions for setup:
 1. Download ~sbcl~ binary release from
    http://www.sbcl.org/platform-table.html.
 2. Install ~sbcl~ with ~su -c "sh install.sh"~.
 3. Download ~quicklisp~ from
    https://beta.quicklisp.org/quicklisp.lisp.
 4. Load ~quicklisp~ with ~sbcl --load "<path-to-quicklisp>"~.
 5. Install ~quicklisp~ with ~(quicklisp-quickstart:install)~ (the
    previous command should have dropped you into the ~sbcl~ REPL).
 6. Add ~quicklisp~ to the startup of ~sbcl~ with
    ~(ql:add-to-init-file)~.

*** Working with Qlot
Qlot is a package manager for Common Lisp that aims to provide
features that are similar to the likes of ~npm~, ~maven~, ~sbt~ and friends.
We'd like to use the Qlot REPL for Slime when we're working on a
project that uses it, here's how to do that.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref qlot :lexical t
  (defun slime-qlot-exec (directory)
    "Exec Slime in DIRECTORY with qlot.

  Source: https://github.com/fukamachi/qlot"
    (interactive (list (read-directory-name "Project directory: ")))
    (slime-start :program "qlot"
                 :program-args '("exec" "ros" "-S" "." "run")
                 :directory directory
                 :name 'qlot
                 :env (list (concat "PATH=" (mapconcat 'identity exec-path ":")))))
#+end_src

** Clojure
Yet another server-based program for editing code in Emacs is CIDER.
It's inspired by SLIME but indented for use with Closure.  I've
installed it because I'm going to a Clojure meet up tomorrow with the
intention of learning the language.  It's really a full day workshop.
Perhaps I'll add to this file as I start customising my Emacs to work
well during the workshop.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref cider :lexical t
  (defun quiescent-setup-clojure-hooks ()
    "Setup hooks for clojure mode."
    (when (null quiescent-starting-up)
      (cider-mode 1)
      (eldoc-mode 1)
      (company-mode 1)))

  (defun quiescent-setup-cider-repl-hooks ()
    "Setup hooks for the clojure repl."
    (when (null quiescent-starting-up)
      (company-mode 1)))

  (use-package cider
    :straight t
    :config
    (progn
      (add-hook 'clojure-mode-hook    #'quiescent-setup-clojure-hooks)
      (add-hook 'cider-repl-mode-hook #'quiescent-setup-cider-repl-hooks)
      (define-key cider-mode-map (kbd "M-n") #'cider-jump-to-compilation-error)
      (define-key cider-mode-map (kbd "M-p") #'cider-jump-to-compilation-error)
      (setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api)
                            (start-figwheel!)
                            (cljs-repl))")))
#+END_SRC

** Emacs Lisp
I write a lot of Emacs lisp these days.  I've started finding it more
convenient to write complex scripts for my operating system using
Emacs lisp rather than anything else.  With that in mind I've started
to aggregate some cool features which I'll use while editing Emacs
Lisp code.

One of the first things that I want to do is port over the live
editing hook I wrote for CIDER into Emacs Lisp so that evaluation
overlays are displayed as I edit the code.  It will also mean that any
Ielm instance I have running will be updated automatically.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref emacs-lisp :lexical t
  <<macrostep>>
  <<debug-signals>>

  (use-package eros
    :straight t)

  ;; From: https://stackoverflow.com/questions/9617183/how-to-find-which-file-provided-the-feature-in-emacs-elisp
  (eval-when-compile (require 'cl-lib))
  (defun locate-feature (feature)
    "Return file name as string where FEATURE was provided."
    (interactive "Sfeature: ")
    (cl-dolist (file-info load-history)
      (mapc (lambda (element)
              (when (and (consp element)
                         (eq (car element) 'provide)
                         (eq (cdr element) feature))
                (message "%s defined in %s" feature (car file-info))
                (cl-return (car file-info))))
            (cdr file-info))))

  (define-key emacs-lisp-mode-map (kbd "C-c C-z") #'quiescent-switch-to-ielm-buffer)
  (define-key emacs-lisp-mode-map (kbd "C-c C-k") #'eval-buffer)

  (defun quiescent-switch-to-ielm-buffer ()
    "Switch to ielm buffer.

  Creates an ielm buffer if one doesn't exist yet."
    (interactive)
    (let ((open-window (cl-loop
                        for window being the windows
                        when (equal "*ielm*" (buffer-name (window-buffer window)))
                        return window))
          (open-buffer (cl-loop
                        for buffer being the buffers
                        when (equal "*ielm*" (buffer-name buffer))
                        return buffer)))
      (cond
       (open-window (select-window open-window))
       (open-buffer (switch-to-buffer-other-window open-buffer))
       (t           (switch-to-buffer-other-window
                     (save-window-excursion
                       (call-interactively #'ielm)
                       (current-buffer)))))))

  (defun quiescent-remove-flex ()
    "Remove the `flex' completion style from completion styles."
    (when (null quiescent-starting-up)
      (setq-local completion-styles '(basic partial-completion emacs22))))

  (add-hook 'emacs-lisp-mode-hook #'quiescent-remove-flex)

  (defun quiescent-eros-mode ()
    "Enable `eros-mode'."
    (when (null quiescent-starting-up)
      (eros-mode 1)))

  (add-hook 'emacs-lisp-mode-hook #'quiescent-eros-mode)

  (defvar quiescent-edebug-previous-value nil
    "The previous value from evaling the last sexp.")

  (defun quiescent-store-last-edebug-value (orig-fun prev-val)
    "Execute ORIG-FUN which should be `edebug-compute-previous-result'.

  Store PREV-VAL in variable."
    (progn
      (setq quiescent-edebug-previous-value (edebug-unwrap* prev-val))
      (funcall orig-fun prev-val)))

  (advice-add #'edebug-compute-previous-result :around #'quiescent-store-last-edebug-value)

  (setq eros-overlays-use-font-lock t)

  (defun quiescent-font-lock-by-mode (major-mode)
    "Font lock the current buffer by MAJOR-MODE."
    (delay-mode-hooks (funcall major-mode))
    (font-lock-default-function 'major-mode)
    (font-lock-default-fontify-region (point-min)
                                      (point-max)
                                      nil))

  (defun quiescent-edebug-add-eros ()
    "Make edebug print eros statements when debugging."
    (when quiescent-edebug-previous-value
      (eros--make-result-overlay (with-temp-buffer
                                   (insert (format "%s" quiescent-edebug-previous-value))
                                   (quiescent-font-lock-by-mode 'emacs-lisp-mode)
                                   (buffer-string))
        :where (point)
        :duration eros-eval-result-duration)))

  (advice-add #'edebug-previous-result :after #'quiescent-edebug-add-eros)

  ;; Inspired by:
  ;; http://superuser.com/questions/669701/emacs-disable-some-minibuffer-messages
  (defmacro quiescent-suppress-eval-output (&rest body)
    "Supress the output of eval around BODY."
    `(cl-flet ((silence (fun value &optional eval-last-sexp-arg-internal) value))
       (unwind-protect
           (progn
             (advice-add #'elisp--eval-last-sexp-print-value :around #'silence)
             ,(car body))
         (advice-remove #'elisp--eval-last-sexp-print-value #'silence))))

  (defun quiescent-el-live-eval ()
    "Evaluate the whole buffer and add overlays to each form."
    (when (eq major-mode 'emacs-lisp-mode)
      (save-excursion
        (goto-char (point-min))
        (let ((message-log-max nil))
          (quiescent-suppress-eval-output
           (while (quiescent-forward-sexp-w/o-error)
             (ignore-errors (eros-eval-last-sexp nil)))
           (ignore-errors (eros-eval-last-sexp nil)))))))
#+END_SRC

While writing Emacs Lisp, I've started to learn edebug and in this
instance I'm using it as a tool for understanding how the semantic db
is being used to do smart completions etc. -- because right now it's a
little bit too slow and it's starting to get in the way of efficiency.

I watched an intro to edebug and here are some of the headlines:

 - Instrument with C-u C-M-x
 - Start debugging by evaluating something which uses it
 - Goto here with 'h'
 - Set a breakpoint with 'b'
 - Continue with 'g'
 - Continue over breakpoints with 'G'
 - Go into a function definition (has to be instrumented) with 'i'
 - Use macro step to exand macros by first calling 'macro-step' and
   then 'e' to expand and 'c' to contract
 - Once expanded, macros can also be debugged.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref macrostep :lexical t
  (use-package macrostep
      :straight t)
#+END_SRC

I recently studied the special form `condition-case'.  This is the
construction in EMACS Lisp which allows the user to handle errors.  It
turns out that debug on error is ignored by condition-case and the
other error handling constructs.  So if I need to debug errors which
are already handled by these constructs then I need another way to
trigger the debugger.

That's where debug on signal comes in.  This is a flag which allows for
the debugging of all signals whether or not they are covered by a
condition-case.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref debug-signals :lexical t
  (defun quiescent-debug-on-all-signals ()
    "Trigger the debugger on all errors whether or not they are in an error handler."
    (interactive)
    (progn
      (setq debug-on-signal t)
      (debug-on-error)))
#+END_SRC

** Scala
I recently started using Ensime.  A mode which is intended to connect
to a server to provide asynchronous parsing of Java and Scala files to
statically analyse the code and improve the editing experience.

It also has some more advanced features such as debugging and running
of the application.  I'm planning on learning as I go.

I recently learned that the development of Ensime has all but halted.
During the time that I used Ensime I found that it would sometimes
struggle with larger projects (like the one which I worked on at work
at the time).  With development coming to a stand still I have very
little hope that these sorts of problems will be rectified.  I've
decided to use the Metals language server instead and so far it's
working just fine.  It lacks some of the auxiliary features of Ensime
(such as interactive development with a REPL and implicit type
conversion hints) but it does the most important stuff (navigation,
completion and error hints) well.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref scala :lexical t
  <<ensime-yasnippet>>
  <<scala-tags>>
  <<scala-edit-string>>

  (use-package scala-mode
      :straight t
      :mode "\\.s\\(cala\\|bt\\)$")

  (use-package sbt-mode
      :straight t
      :commands sbt-start sbt-command
      :config
      ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
      ;; allows using SPACE when in the minibuffer
      (substitute-key-definition
       'minibuffer-complete-word
       'self-insert-command
       minibuffer-local-completion-map))

  (add-hook 'sbt-mode-hook (lambda ()
                             (add-hook 'before-save-hook 'sbt-hydra:check-modified-buffers)))

  (advice-add #'ensime-mode :around #'ignore)

  (defun quiescent-remove-flex ()
    "Remove the `flex' completion style from completion styles."
    (when (null quiescent-starting-up)
      (setq-local completion-styles '(basic partial-completion emacs22))))

  (add-hook 'scala-mode-hook #'quiescent-remove-flex)

  (defun quiescent-ensure-eglot ()
    "Enable eglot in the curernt buffer."
    (when (null quiescent-starting-up)
      (eglot-ensure)))

  (use-package eglot
      :straight t
      :config
      (progn
        (add-to-list 'eglot-server-programs '(scala-mode . ("metals-emacs")))
        (setq eglot-server-programs
              (map-delete eglot-server-programs 'rustic-mode))
        (add-to-list 'eglot-server-programs '(rustic-mode . ("rust-analyzer")))
        (add-hook 'scala-mode-hook #'eglot-ensure)
        (add-hook 'rust-mode-hook  #'eglot-ensure)))

  (defun scala-mode--find-project-root (directory)
    "Produce the root of SBT project containing DIRECTORY.

  Assumes that you use SBT."
    (when (null quiescent-starting-up)
      (let ((sbt-root (locate-dominating-file directory "build.sbt")))
     (when sbt-root
       (cons 'sbt sbt-root)))))

  (require 'project)

  (add-hook 'project-find-functions #'scala-mode--find-project-root)

  (cl-defmethod project-roots ((project (head sbt)))
    (list (cdr project)))

  (cl-defmethod project-files ((project (head sbt)) &optional dirs)
    (project-files (project-try-vc (car (project-roots project))) dirs))
#+END_SRC

Ensime has a strange interaction with yasnippet.  This needs to be
corrected much like the code I have for making indentation, completion
etc. work in other modes.  This is done by simply deferring the TAB
binding to another mode (i.e. not overwriting it for scala-mode
alone.)

UPDATE: I'm not sure whether this is necessary since I switched to LSP
for Scala.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref ensime-yasnippet :lexical t
  (require 'yasnippet)

  (defun ensime-company-enable ()
    (make-local-variable 'company-backends)
    (push #'ensime-company company-backends)
    (company-mode t)
    (define-key yas-minor-mode-map [(tab)]     yas-maybe-expand)
    (define-key yas-minor-mode-map (kbd "TAB") yas-maybe-expand))
#+END_SRC

*** Scala Tags
I sometimes use tags when ensime is just failing hard.  In those cases
I need a few tweaks to get it to work.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref scala-tags :lexical t
  (setq semantic-symref-filepattern-alist
        '((c-mode "*.[ch]")
          (c++-mode "*.[chCH]" "*.[ch]pp" "*.cc" "*.hh")
          (html-mode "*.html" "*.shtml" "*.php")
          (mhtml-mode "*.html" "*.shtml" "*.php")
          (ruby-mode "*.r[bu]" "*.rake" "*.gemspec" "*.erb" "*.haml" "Rakefile" "Thorfile" "Capfile" "Guardfile" "Vagrantfile")
          (python-mode "*.py" "*.pyi" "*.pyw")
          (perl-mode "*.pl" "*.PL")
          (cperl-mode "*.pl" "*.PL")
          (lisp-interaction-mode "*.el" "*.ede" ".emacs" "_emacs")
          (scala-mode "*.scala" "*.sc")))
#+END_SRC

*** Scala Edit String
Two colleagues of mine were recently working on a code generator for
an API based on YAML description files.  The generator contains large
segments of Scala in strings.  It's difficult to maintain those
strings because you don't have syntax highlighting etc.  I realised
that you could make like markdown/org mode and edit these strings in
their own buffers.  This is what I came up with in about 10 minutes.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref scala-edit-string :lexical t
  (defun ed-edit-scala-string ()
    "Edit scala string in an indirect buffer."
    (interactive)
    (save-excursion
      (if (fboundp 'edit-indirect-region)
          (let* ((dotted-bounds (save-excursion
                                  (search-backward "\"\"\"")
                                  (bounds-of-thing-at-point 'sexp)))
                 (bounds (list (+ (car dotted-bounds) 3) (- (cdr dotted-bounds) 3)))
                 (begin (and bounds (goto-char (nth 0 bounds)) (point-at-bol 2)))
                 (end (and bounds (goto-char (nth 1 bounds)) (point-at-bol 1))))
            (if (and begin end)
                (let* ((lang "scala")
                       (mode (and lang (markdown-get-lang-mode lang)))
                       (edit-indirect-guess-mode-function
                        (lambda (_parent-buffer _beg _end)
                          (funcall mode))))
                  (edit-indirect-region begin end 'display-buffer))
              (user-error "Not inside a GFM or tilde fenced code block")))
        (when (y-or-n-p "Package edit-indirect needed to edit code blocks. Install it now? ")
          (progn (package-refresh-contents)
                 (package-install 'edit-indirect)
                 (markdown-edit-code-block))))))
#+END_SRC

** Docker
Docker has it's own syntax for "Dockerfiles".  This is font locked in
the Dockerfile package.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref dockerfile :lexical t
  (use-package dockerfile-mode
      :straight t)
#+END_SRC

** Kotlin
At some point the developers of the best IDE out there (IntelliJ Idea)
figured out that, with the way that Java generally gets written, it's
pretty hard to make a robust application.  The developers embarked on
the task of making a better Java without making it "complicated" like
functional programming.  In my opinion this was a terrible idea
because they've encoded a lot of ideas from functional programming
without leveraging the rigorous methodologies which underpin it.  This
means that their abstractions have flaws: null pointer exceptions are
easy to come by for instance and functions aren't quite first class.
Either way it's still better than Java for the kind of programming
which enterprise Java made popular and I come across it from time to
time so I decided to install it.  I also needed to work on the engine
of the Entelect Challenge in 2019 (the year in which I'm writing this!
:P).

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref kotlin :lexical t
  (use-package kotlin-mode
      :straight t)
#+END_SRC

** Terraform
Terraform is a configuration language for deploying AWS cloud
infrastructure.  I'm using it at work and a mode for editing the file
would be nice.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref terraform :lexical t
  (use-package terraform-mode
      :straight t)
#+END_SRC

** Emacs Jupyter
So I'm starting a data science and ML course to get up to speed with
the field quickly.  The medium for instruction is Jupyter notebooks.
I'd really rather that the medium be Emacs so I'm going to setup
`emacs-jupyter' so that I can edit blocks from org mode and make my
own notes as we go.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref emacs-jupyter :lexical t
  (use-package jupyter
    :straight t)
#+end_src

** Python
I've been making various customisations to my Python setup as I do
more data work.  I've decided to group the modifications into a
section so that it's easier to manage all of the Python related
changes which I'm implementing.

*** Pyenv
Sometimes what you want to be able to use a different python
environment when you're doing stuff in Emacs.  ~pyenv~ makes this
quite simple to do.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref pyvenv :lexical t
  (use-package pyvenv
    :load-path "~/.emacs.d/lisp/pyvenv/")

  (defun quiescent-python-use-conda ()
    "Use an anaconda environment for python development."
    (interactive)
    (progn
      (setenv "WORKON_HOME" "~/anaconda3/envs")
      (pyvenv-mode 1)))

  (defun quiescent-python-use-spark ()
    "Use spark to start python shells."
    (interactive)
    (setq python-shell-interpreter "pyspark"))
#+end_src

*** Python Completion
Python's completion setup includes semantic and a couple of other slow
things by default.  I've decided to limit it to a select few instead.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref python-completion :lexical t
  (defun quiescent-setup-python-company-completion ()
    "Setup completion for use with Python."
    (setq-local company-backends
                '(company-capf company-dabbrev-code company-files company-keywords))
    (setq-local completion-at-point-functions
                '(python-completion-at-point)))

  (add-hook 'python-mode-hook #'quiescent-setup-python-company-completion)
#+end_src

** C++
I haven't written c++ in a while.  I figure, though, that it's an
important skill to keep sharp.  So I'm creating a basic configuration
here for CodeWars training and I'll iterate on it as needed.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref c-plus-plus :lexical t
  (defun quiescent-setup-c++-completion ()
      "Setup completion for c++ mode."
      (when (null quiescent-starting-up)
        (company-mode 1)
        (setq-local company-backends '(company-capf company-dabbrev))
        (setq-local completion-at-point-functions '(tags-completion-at-point-function))))

  (add-hook 'c++-mode-hook #'quiescent-setup-c++-completion)
#+end_src

If you want to use ~ccls~ then you have to build it and install it
from source.  This is how I did it.

#+begin_src bash :tangle no
  git  submodule update --init -- third_party/rapidjson;
  wget -c http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz;
  tar xf clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz;
  cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=$PWD/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04;
  cmake --build Release;
  cmake --build Release --target install
#+end_src

** C
C is, for the most part, like C++ in it's setup.  There are just some
extra variables which need tweaking to make it all work.

#+begin_src  emacs-lisp :tangle no :noweb yes :noweb-ref c :lexical t
  (defun quiescent-setup-c-completion ()
      "Setup completion for `c-mode'."
      (when (null quiescent-starting-up)
        (company-mode 1)
        (setq-local company-backends '(company-capf company-dabbrev))
        (setq-local completion-at-point-functions '(tags-completion-at-point-function))))

  (add-hook 'c-mode-hook #'quiescent-setup-c-completion)
#+end_src

** Racket
I'm brushing up on my Racket as part of Code Wars training.  It should
be fun!  The last time that I used Racket was a course a few years
ago.  During the course I used Dr. Racket.  I think that I'd like to
try again with Emacs this time.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref racket :lexical t
  (use-package racket-mode
    :straight t)
#+end_src

** Ado Mode
Stata is a proprietary statistical analysis program.  It's being used
by the OpenSafely team at Oxford.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref ado-mode :lexical t
  (use-package ado-mode
    :load-path "~/.emacs.d/lisp/ado-mode/lisp")
#+end_src

** Ruby
I occasionally edit ruby files.  More recently I've done this in the
context of modifying Chef scripts.  I'd like to make sure that my Ruby
setup is adequate and that my skills are sharp so I'll do problems in
Ruby occasionally.  This setup was added as part of solving problems
on CodeWars.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref enh-ruby :lexical t
  (use-package enh-ruby-mode
    :straight t
    :config
    (progn
      (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
      (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
      (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))))

  (defun quiescent-setup-ruby-completion ()
    "Setup completion for `enh-ruby-mode'."
    (when (null quiescent-starting-up)
      (setq-local company-backends '(company-robe company-capf company-dabbrev))
      (setq-local completion-at-point-functions '(tags-completion-at-point-function))))

  (use-package robe
    :straight t
    :config
    (progn
      (add-hook 'enh-ruby-mode-hook #'robe-mode)
      (add-hook 'enh-ruby-mode-hook #'quiescent-setup-ruby-completion)))
#+end_src

** R
R is a programming language which targets the audience of Scientists
and Engineers who are interested in statistics and data modelling.

The most popular way to view and edit R is to use the Emacs Speaks
Statistics (ESS) package.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref ess :lexical t
  (use-package ess
    :straight t)
#+end_src

** Swift
I'm working on a project that has an iOS app.  I'm adding support for
Swift files.

   #+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref swift :lexical t
     (use-package swift-mode
       :straight t)
   #+end_src

** C Sharp
I sometimes need to write c-sharp.  So here goes.  Last time I tried,
it wasn't great in Emacs.

#+begin_src emacs-lisp  :tangle no :noweb yes :noweb-ref c-sharp :lexical t
  (use-package csharp-mode
    :straight t)
#+end_src

* Non-Programming Usages
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref non-programming-usages :exports none :lexical t
  <<gnus>>
  <<csv>>
  <<ibuffer>>
  <<bufler>>
  <<isearchb>>
  <<markdown>>
  <<dired-mode>>
  <<eww>>
  <<org-mode>>
  <<htmlize>>
  <<epresent>>
  <<demo-it>>
  <<org-tree-slide>>
  <<magit-setup>>
  <<magit-insert-files>>
  <<abridge-diff>>
  <<git-commands>>
  <<chess>>
  <<typing-game>>
  <<slock>>
  <<tramp>>
  <<gnuplot>>
  <<4clojure>>
  <<erc>>
  <<bbdb>>
  <<rest-client>>
  <<linkd>>
  <<calctex>>
  <<excorporate>>
  <<screenshot>>
  <<mu4e>>
#+END_SRC

** GNUs
GNUs is a news reader and mail client.  It has a very minimalist
interface but is gigantic in it's scope.  Right now I'm only beginning
my adventure into this incredibly cool mode, as I go I'll keep this
updated with what I find.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref gnus :lexical t
  (defun quiescent-gnus-summary-toggle-header ()
    "Run summary toggle header."
    (when (null quiescent-starting-up)
      (gnus-summary-toggle-header)))

  (add-hook 'gnus-article-mode-hook
         #'quiescent-gnus-summary-toggle-header)
#+END_SRC

** E Reader
Unfortunately I don't have a program installed for reading e-books.
There's an Emacs package which does do it though so I'm going to give
it a bash and see if it can provide the 99% of what I need.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref e-reader none :lexical t
  (use-package ereader
    :straight t)
#+END_SRC

** CSV Data
A lot of data is distributed as CSV because it's a universal format
and it's very easy to parse.  However, viewing a CSV file can be
difficult because the data can easily span multiple lines with
wrapping and it can also be difficult to extract and work with data in
the file.

CSV mode provides facilities to align and manipulate data stored in
CSV files.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref csv :lexical t
  (use-package csv-mode
      :straight t)
#+END_SRC

** iBuffer Mode
iBuffer is a built in package in emacs which makes controlling buffers
more powerful.  It provides a dired like interface with advanced
filtering features for dealing with types of buffers in bulk.

I've added some configuration to make the names column wider and group
buffers by projectile project.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref ibuffer :lexical t
  (require 'ibuffer)

  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (autoload 'ibuffer "ibuffer" "List buffers." t)

  (setq ibuffer-formats
        '((mark modified read-only " "
           (name 35 35 :left :elide) ; change: 30s were originally 18s
           " "
           (size 9 -1 :right)
           " "
           (mode 16 16 :left :elide)
           " " filename-and-process)
          (mark " "
           (name 16 -1)
           " " filename)))
#+END_SRC

** Bufler
I recently came across a command for switching between and organising
buffers which automatically groups buffers together.  It's written by
the same guy who wrote ~prism~.  I'm going to use it for switching
buffers, because I think that it could be helpful when working with
multiple projects.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref bufler :lexical t
  (use-package bufler
    :straight t
    :config (progn
              (setq bufler-face-prefix "prism-level-")))
#+END_SRC

** iSearchb
iSearchB is a built in package which is like isearch, in that it's
interactive, but it searches through your buffer list.

Q: How is this different from any of the other methods of switching
buffers?

A: It shows the target buffer as you're typing!

e.g. Suppose that you want to switch to *Help* and you have buffers
named:
 - have-a-nice-day.el
 - its-heavy.txt
 - \*Help\*
open.

When you activate iSearchb and type "h" the best match is the first
buffer, have-a-nice-day.el.  It will immediately show you the contents
of that buffer.  If you then type "e" it matches the second buffer
its-heavy.txt, which is then shown.  Finally if you type the "l" it
only matches the \*Help\* buffer so it shows that.  At any point you
can hit a movement key and it'll stay on that buffer -- totally
awesome!!!  I've bound it to =C-z=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref isearchb :lexical t
  (define-key global-map [(control ?z)] 'isearchb-activate)
#+END_SRC

** Markdown
A lot of online manuals and media is written in markdown because if
it's brief and easy to read syntax without marking up the source to a
published format.  It's a lot like org-mode, but doesn't include nearly
as many features.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref markdown :lexical t
  (use-package markdown-mode
      :straight t)
#+END_SRC

** Dired Mode
Emacs has a powerful model for editing directories and files which
presents files to the user in an interactive view which looks like an
=ls -lh= interface.  The idea comes from an old program which I believe
was installed on IBM computers.  The idea is that one can select
navigate and perform file-systemish tasks on the files such as copying
and altering privileges of files and directories.

In this view I prefer that I can't see executable files and object
files, because I'll never have to open them or move them about and if
I want to delete them I can just use a glob pattern in eshell or
=M-x delete-file=.

NOTE: It looks like the config. to exclude certain files has gone
missing :/

I can also tweak a few of the settings in plain old vanilla dired mode
such as a setting which sets the default destination buffer when you
copy files.

There is a list of dired hacks which adds some totally cool features
to dired.  The first of these that I'm trying out is a feature which
makes the sub directory opening more like a tree view.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref dired-mode :lexical t
  (use-package dired-x
      :config (progn
          (setq dired-omit-mode t)
          (setq dired-omit-files "^\\.[^.]\\|\\.hi$\\|\\.o$\\|\\.exe$")))

  (setq dired-dwim-target t)

  (use-package dired-subtree
      :straight t
      :config (define-key dired-mode-map (kbd ",") 'dired-subtree-toggle))

  (defun quiescent-dired-filter-group-mode ()
    "Enable `dired-filter-group-mode'."
    (when (null quiescent-starting-up)
      (dired-filter-group-mode 1)))

  (use-package dired-filter
    :straight t
    :config
    (progn
      (define-key dired-mode-map (kbd "C-c C-'") #'dired-filter-group-mode)
      (add-hook 'dired-mode-hook #'quiescent-dired-filter-group-mode)
      (setq dired-filter-group-saved-groups
            '(("default"
               ("PDF"
                (extension . "pdf"))
               ("LaTeX"
                (extension "tex" "bib"))
               ("Org"
                (extension . "org"))
               ("Archives"
                (extension "zip" "rar" "gz" "bz2" "tar"))
               ("Folders"
                (directory))
               ("Source Code"
                (extension "el" "scala" "rs" "asm"
                           "cl" "lisp" "el" "c"
                           "h" "c++" "h++" "hpp"
                           "hxx" "m" "cc" "cs"
                           "cp" "cpp" "go" "f"
                           "for" "ftn" "f90" "f95"
                           "f03" "f08" "s" "rs"
                           "hi" "hs" "py" "java"
                           "sh" "asd")))))))

  (use-package diredfl
    :straight t
    :config
    (progn
      ;; My modifications to the font locking
      (defface quiescent-diredfl-autofile-name
        '((t (:foreground "#3f444a"))) ; Very dark blue
        "*Face used in Dired for names of files that are autofile bookmarks."
        :group 'diredfl)
      (setq diredfl-autofile-name 'quiescent-diredfl-autofile-name)

      (defface quiescent-diredfl-compressed-file-name
        '((t (:foreground "#ECBE7B")))
        "*Face used for compressed file names."
        :group 'diredfl)
      (setq diredfl-compressed-file-name 'quiescent-diredfl-compressed-file-name)

      (defface quiescent-diredfl-compressed-file-suffix
        '((t (:foreground "#905e3c")))
        "*Face used for compressed file suffixes in Dired buffers.
  This means the `.' plus the file extension.  Example: `.zip'."
        :group 'diredfl)
      (setq diredfl-compressed-file-suffix 'quiescent-diredfl-compressed-file-suffix)

      (defface quiescent-diredfl-date-time
        '((t (:foreground "#46D9FF")))
        "*Face used for date and time in Dired buffers."
        :group 'diredfl)
      (setq diredfl-date-time 'quiescent-diredfl-date-time)

      (defface quiescent-diredfl-deletion
        '((t (:foreground "#ff6c6b")))
        "*Face used for deletion flags (D) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-deletion 'quiescent-diredfl-deletion)

      (defface quiescent-diredfl-deletion-file-name
        '((t (:foreground "#ff6c6b")))
        "*Face used for names of deleted files in Dired buffers."
        :group 'diredfl)
      (setq diredfl-deletion-file-name 'quiescent-diredfl-deletion-file-name)

      (defface quiescent-diredfl-dir-heading
        '((t (:foreground "#51afef")))
        "*Face used for directory headings in Dired buffers."
        :group 'diredfl)
      (setq diredfl-dir-heading 'quiescent-diredfl-dir-heading)

      (defface quiescent-diredfl-dir-name
        '((t (:foreground "#51afef")))
        "*Face used for directory names."
        :group 'diredfl)
      (setq diredfl-dir-name 'quiescent-diredfl-dir-name)

      (defface quiescent-diredfl-dir-priv
        '((t (:foreground "#51afef")))
        "*Face used for directory privilege indicator (d) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-dir-priv 'quiescent-diredfl-dir-priv)

      (defface quiescent-diredfl-exec-priv
        '((t (:foreground "#98be65")))
        "*Face used for execute privilege indicator (x) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-exec-priv 'quiescent-diredfl-exec-priv)

      ;; For this to show up, you need `F' among the options in `dired-listing-switches'.
      ;; For example, I use "-alF" for `dired-listing-switches'.
      (defface quiescent-diredfl-executable-tag
        '((t (:foreground "#98be65")))
        "*Face used for executable tag (*) on file names in Dired buffers."
        :group 'diredfl)
      (setq diredfl-executable-tag 'quiescent-diredfl-executable-tag)

      (defface quiescent-diredfl-file-name
        '((t (:foreground "#bbc2cf")))
        "*Face used for file names (without suffixes) in Dired buffers.
  This means the base name.  It does not include the `.'."
        :group 'diredfl)
      (setq diredfl-file-name 'quiescent-diredfl-file-name)

      (defface quiescent-diredfl-file-suffix
        '((t (:foreground "#7d828d")))
        "*Face used for file suffixes in Dired buffers.
  This means the `.' plus the file extension.  Example: `.elc'."
        :group 'diredfl)
      (setq diredfl-file-suffix 'quiescent-diredfl-file-suffix)

      (defface quiescent-diredfl-flag-mark
        '((t (:foreground "#ECBE7B")))
        "*Face used for flags and marks (except D) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-flag-mark 'quiescent-diredfl-flag-mark)

      (defface quiescent-diredfl-flag-mark-line
        '((t (:foreground "#787831311414")))
        "*Face used for flagged and marked lines in Dired buffers."
        :group 'diredfl)
      (setq diredfl-flag-mark-line 'quiescent-diredfl-flag-mark-line)

      (defface quiescent-diredfl-ignored-file-name
        '((t (:foreground "#5B6268")))
        "*Face used for ignored file names  in Dired buffers."
        :group 'diredfl)
      (setq diredfl-ignored-file-name 'quiescent-diredfl-ignored-file-name)

      (defface quiescent-diredfl-link-priv
        '((t (:foreground "#a9a1e1")))
        "*Face used for link privilege indicator (l) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-link-priv 'quiescent-diredfl-link-priv)

      (defface quiescent-diredfl-no-priv
        '((t (:foreground "#bbc2cf")))
        "*Face used for no privilege indicator (-) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-no-priv 'quiescent-diredfl-no-priv)

      (defface quiescent-diredfl-number
        '((t (:foreground "#da8548")))
        "*Face used for numerical fields in Dired buffers.
  In particular, inode number, number of hard links, and file size."
        :group 'diredfl)
      (setq diredfl-number 'quiescent-diredfl-number)

      (defface quiescent-diredfl-other-priv
        '((t (:foreground "#c678dd")))
        "*Face used for l,s,S,t,T privilege indicators in Dired buffers."
        :group 'diredfl)
      (setq diredfl-other-priv 'quiescent-diredfl-other-priv)

      (defface quiescent-diredfl-rare-priv
        '((t (:foreground "#bbc2cf")))
        "*Face used for rare privilege indicators (b,c,s,m,p,S) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-rare-priv 'quiescent-diredfl-rare-priv)

      (defface quiescent-diredfl-read-priv
        '((t (:foreground "#ECBE7B")))
        "*Face used for read privilege indicator (w) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-read-priv 'quiescent-diredfl-read-priv)

      (defface quiescent-diredfl-symlink
        '((t (:foreground "#a9a1e1")))
        "*Face used for symbolic links in Dired buffers."
        :group 'diredfl)
      (setq diredfl-symlink 'quiescent-diredfl-symlink)

      (defface quiescent-diredfl-tagged-autofile-name
        '((t (:foreground "#5B6268"))) ; Very pale green
        "*Face used in Dired for names of files that are autofile bookmarks."
        :group 'diredfl)
      (setq diredfl-tagged-autofile-name 'quiescent-diredfl-tagged-autofile-name)

      (defface quiescent-diredfl-write-priv
        '((t (:foreground "#ff6c6b")))
        "*Face used for write privilege indicator (w) in Dired buffers."
        :group 'diredfl)
      (setq diredfl-write-priv 'quiescent-diredfl-write-priv)

      (defconst quiescent-diredfl-font-lock-keywords-1
        (list
         '("^  \\(.+:\\)$" 1 diredfl-dir-heading) ; Directory headers
         '("^  wildcard.*$" 0 'default)       ; Override others, e.g. `l' for `diredfl-other-priv'.
         '("^  (No match).*$" 0 'default)     ; Override others, e.g. `t' for `diredfl-other-priv'.
         '("[^ .]\\(\\.[^. /]+\\)$" 1 diredfl-file-suffix) ; Suffix, including `.'.
         '("\\([^ ]+\\) -> .+$" 1 diredfl-symlink) ; Symbolic links

         ;; 1) Date/time and 2) filename w/o suffix.
         ;;    This is a bear, and it is fragile - Emacs can change `dired-move-to-filename-regexp'.
         `(,dired-move-to-filename-regexp
           (7 diredfl-date-time t t)         ; Date/time, locale (western or eastern)
           (2 diredfl-date-time t t)         ; Date/time, ISO
           (,(concat "\\(.+\\)\\(" (concat (funcall #'regexp-opt diredfl-compressed-extensions)
                                           "\\)[*]?$"))
            nil nil (0 diredfl-compressed-file-name keep t))) ; Compressed-file suffix
         `(,dired-move-to-filename-regexp
           (7 diredfl-date-time t t)         ; Date/time, locale (western or eastern)
           (2 diredfl-date-time t t)         ; Date/time, ISO
           ("\\(.+\\)$" nil nil (0 diredfl-file-name keep t))) ; Filename (not a compressed file)

         ;; Files to ignore
         (list (concat "^  \\(.*\\("
                       (mapconcat #'regexp-quote (or (and (boundp 'dired-omit-extensions)  dired-omit-extensions)
                                                     completion-ignored-extensions)
                                  "[*]?\\|")
                       (and diredfl-ignore-compressed-flag
                            (concat "\\|" (mapconcat #'regexp-quote diredfl-compressed-extensions "[*]?\\|")))
                       "[*]?\\)\\)$") ; Allow for executable flag (*).
               1 diredfl-ignored-file-name t)

         ;; Compressed-file (suffix)
         (list (concat "\\(" (concat (funcall #'regexp-opt diredfl-compressed-extensions) "\\)[*]?$"))
               1 diredfl-compressed-file-suffix t)
         '("\\([*]\\)$" 1 diredfl-executable-tag t) ; Executable (*)

         ;; Inode, hard-links, & file size (. and , are for the decimal point, depending on locale)
         ;; See comment for `directory-listing-before-filename-regexp' in `files.el' or `files+.el'.
         '("\\_<\\(\\([0-9]+\\([.,][0-9]+\\)?\\)[BkKMGTPEZY]?[ /]?\\)" 1 'quiescent-diredfl-number)

         ;; Directory names - exclude d:/..., Windows drive letter in a dir heading.
         (list (concat dired-re-maybe-mark dired-re-inode-size "\\(d\\)[^:]")
               '(1 diredfl-dir-priv t) '(".+" (dired-move-to-filename) nil (0 diredfl-dir-name t)))

         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]........\\(x\\)") ; o x
               '(1 diredfl-exec-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]........\\([lsStT]\\)") ; o misc
               '(1 diredfl-other-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].......\\(w\\).") ; o w
               '(1 diredfl-write-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]......\\(r\\)..") ; o r
               '(1 diredfl-read-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].....\\(x\\)...") ; g x
               '(1 diredfl-exec-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].....\\([lsStT]\\)...") ; g misc
               '(1 diredfl-other-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]....\\(w\\)....") ; g w
               '(1 diredfl-write-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]...\\(r\\).....") ; g r
               '(1 diredfl-read-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]..\\(x\\)...") ; u x
               '(1 diredfl-exec-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]..\\([lsStT]\\)...") ; u misc
               '(1 diredfl-other-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].\\(w\\)....") ; u w
               '(1 diredfl-write-priv))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]\\(r\\).....") ; u r
               '(1 diredfl-read-priv))

         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]........\\([-rwxlsStT]\\)") ; o -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].......\\([-rwxlsStT]\\).") ; g -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]......\\([-rwxlsStT]\\)..") ; u -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].....\\([-rwxlsStT]\\)...") ; o -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]....\\([-rwxlsStT]\\)....") ; g -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]...\\([-rwxlsStT]\\).....") ; u -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]..\\([-rwxlsStT]\\)......") ; o -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].\\([-rwxlsStT]\\).......") ; g -
               '(1 diredfl-no-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]\\([-rwxlsStT]\\)........") ; u -
               '(1 diredfl-no-priv keep))

         (list (concat dired-re-maybe-mark dired-re-inode-size "\\([bcsmpS]\\)") ; (rare)
               '(1 diredfl-rare-priv keep))
         (list (concat dired-re-maybe-mark dired-re-inode-size "\\(l\\)[-rwxlsStT]") ; l
               '(1 diredfl-rare-priv keep))

         (list (concat "^\\([^\n " (char-to-string dired-del-marker) "].*$\\)")
               '(1 diredfl-flag-mark-line prepend))                          ; Flag/mark lines
         (list (concat "^\\([^\n " (char-to-string dired-del-marker) "]\\)") ; Flags, marks (except D)
               '(1 diredfl-flag-mark prepend))

         (list (concat "^\\([" (char-to-string dired-del-marker) "].*$\\)") ; Deletion-flagged lines
               '(1 diredfl-deletion-file-name prepend))
         (list (concat "^\\([" (char-to-string dired-del-marker) "]\\)") ; Deletion flags (D)
               '(1 diredfl-deletion prepend))))))

  (defun quiescent-add-third-level-font-lock ()
    "Add my own font locking afterwards to fix the background."
    (when (null quiescent-starting-up)
      (setq font-lock-defaults
         '((dired-font-lock-keywords
            dired-font-lock-keywords
            diredfl-font-lock-keywords-1
            quiescent-diredfl-font-lock-keywords-1)
           t nil nil beginning-of-line))
      (font-lock-refresh-defaults)))

  (add-hook 'diredfl-mode-hook #'quiescent-add-third-level-font-lock)

  (diredfl-global-mode 1)
#+END_SRC

** EWW
Emacs now comes with a web browser! =:D= I use it to create system
specific tasks and to browse things on the net without leaving
Emacs.  In that way it helps me be more productive by not context
switching or being distracted by adds and animation.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref eww :lexical t
  (setq browse-url-browser-function 'eww-browse-url)
#+END_SRC

** Org Mode
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-mode :exports none :lexical t
  <<load-org>>
  <<org-bullets>>
  <<org-dependencies>>
  <<org-reveal>>
  <<secretaria>>
  <<org-brain>>
  <<org-pomodoro>>
#+END_SRC
Note: this section was heavily modified and the flow might not make a
whole lot of sense anymore.  I've aggregated all of the code blocks
which used to be here into one included file.

Org mode is a system which supports structured note taking, document
typesetting, organisation and literate programming.  It's what I've
used to put this literate program together.  I use org mode to organise
my work and keep track of what I do.  Part of that is staging tasks and
keeping track of the state that they're in.  I've added ``NEXT'',
``STARTED'' and ``SUSPENDED'' as keywords to represent important
intermediary steps in my work flow so that I can better track my progress.

In org mode you can have several files which Emacs will load when you
ask for an agenda through org mode.  Because these will be at different
locations depending on the projects being worked on, on a particular
computer, we require for the list of agenda files to be loaded
separately for this configuration not to break when deployed.

Org mode is capable of exporting to many formats.  What I've found
using the HTML exporter is that images can be very poorly rendered in
terms of their width.  I got the following snippet from an [[http://stackoverflow.com/questions/11670654/how-to-resize-images-in-org-mode][SO article]]
to allow for image widths to be set, e.g.

#+BEGIN_EXAMPLE
#+ATTR_HTML: width="100px"
[[~/images/example.jpg]]
#+END_EXAMPLE

I like writing technical specifications in org mode.  I use plant UML
to generate UML diagrams from text based specifications.  This is
especially nifty because I can write the entire darn thing in org
(plain text!) and have it exported to various formats including
diagrams of the system and it's functionality.

Finally when writing literate programs and other documents which
include source code, it's useful to have org apply the correct font
lock to the code both for editing and for exporting.  Org fontify
natively does this in org file that you're editing and the LaTeX
options ensure that listings is used when exporting to PDF via LaTeX.

The "o" template for agenda views comes from
https://github.com/psamim/dotfiles.  psamim designed a very minimal
and clean UI using icons and I adapted it to my workflow.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref load-org :lexical t
  (use-package epa-file
    :config (epa-file-enable))

  (defun quiescent-org-capture (&optional goto keys)
    "Capture a note to org capture.

  Places some context into registers for using while capturing the
  note.  I have plans to pick up dates and set the scheduled date
  accordingly, but that hasen't been done yet.

  Optional arguments GOTO and KEYS are supplied to `org-capture'
  itself."
    (interactive)
    (progn
      (copy-to-register ?l
                        (save-excursion (beginning-of-line) (point))
                        (save-excursion (end-of-line)       (point))))
    (org-capture goto keys))

  (defvar quiescent-org-reloaded nil
    "Nil if `org-mode' wasn't yet reloaded.")

  (with-eval-after-load 'org
    (when (not quiescent-org-reloaded)
      (org-reload)
      (setq quiescent-org-reloaded t)))

  (defun quiescent-setup-agenda-line-spacing ()
    "Setup line spacing for my agenda in org mode."
    (setq-local line-spacing 5))

  (defun quiescent-activate-hl-line-mode ()
    "Activate `hl-line-mode' in the current buffer."
    (hl-line-mode t))

  (add-hook 'org-agenda-mode-hook #'quiescent-setup-agenda-line-spacing)
  (add-hook 'org-agenda-mode-hook #'quiescent-activate-hl-line-mode)

  (defun quiescent-setup-org-babel-languages()
    "Setup and load the org-babel languages."
    (progn
      (setq org-babel-load-languages
            (quote
             ((emacs-lisp . t)
              (plantuml . t)
              (dot . t)
              (ditaa . t)
              (gnuplot . t)
              (shell . t)
              (python t)
              (calc . t)
              (lisp . t)
              (js . t)
              (jupyter . t))))
      (setq org-log-into-drawer 'LOGBOOK)
      (org-babel-do-load-languages
       'org-babel-load-languages org-babel-load-languages)))

  (setq org-babel-js-function-wrapper
    "console.log(`${require('util').inspect(function(){\n%s\n}())}`);")

  (use-package ob-async
    :straight t)

  (add-hook 'after-init-hook #'quiescent-setup-org-babel-languages)

  (setq org-capture-templates
        (quote (("w" "Work" entry (file "~/Dropbox/org/work.org")
                 "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t))\n%U\n%a\n")
                ("g" "Games" entry (file "~/Dropbox/org/games.org")
                 "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t))\n%U\n%a\n")
                ("m" "Maintenance" entry (file "~/Dropbox/org/maintenance.org")
                 "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t))\n%U\n%a\n")
                ("e" "Edits" entry (file "~/edits.org")
                 "* %?\n%U\n%a\n")
                ("p" "Programming Notes" entry (file "~/notes/programming.gpg")
                 "* %?\n%U\n%a\n")
                ("s" "Social" entry (file "~/notes/social.gpg")
                 "* %?\n%U\n%a\n")
                ("j" "Journal" entry (file+olp+datetree "~/wip/journal/journal.org")
                 "** %<%H:%M> %?\n"))))

  (define-key org-mode-map (kbd "M-i") #'org-goto)
  (advice-add #'org-goto :before #'push-mark)
  (define-key org-mode-map (kbd "C-c C--") #'q-insert-checkbox)

  (use-package ob-gnuplot)
  (use-package ob-shell)
  (use-package ob-python)
  (use-package ob-mermaid
    :straight t)
  (use-package cider
    :straight t
    :demand t)
  (use-package ob-clojure
    :init (setq org-babel-clojure-backend 'cider))

  (require 'cl-lib)

  (defun quiescent-render-html--overlays (beg end)
    "Get the overlays in region [BEG, END) which are used by `quiescent-render-html'."
    (cl-remove-if-not (lambda (overlay) (overlay-get overlay 'render-html))
                      (overlays-in beg end)))

  (defun quiescent-render-html-ob-export ()
    "Renders all html output blocks in the current buffer.

  Uses `shr-render-buffer' to render the block.  When the point
  enters the region then it reveals the original contents.

  The original text is stored in an overlay property and revealed
  when the point enters the region using the post command hook:
  `quiescent--org-pretty-render-post-command-hook'."
    (interactive)
    (save-window-excursion
      (quiescent-render-html-register-hook)
      (goto-char (point-min))
      (quiescent-render-html-unrender-all)
      (while (search-forward "#+begin_export html" nil t)
        (let* ((start         (progn (beginning-of-line) (point)))
               (start-content (progn (end-of-line) (forward-char 1) (point)))
               (end           (progn (goto-char (org-babel-result-end)) (point)))
               (end-content   (progn (forward-line -1) (point)))
               (overlays      (quiescent-render-html--overlays (point-min) (point-max))))
          (mapc #'delete-overlay overlays)
          (let* ((original-content (buffer-substring start-content end-content))
                 (rendered-content (with-temp-buffer
                                     (insert original-content)
                                     (shr-render-buffer (current-buffer))
                                     (buffer-substring (point-min) (point-max)))))
            (quiescent-render-html-insert-rendered (make-overlay start end)
                                                   (buffer-substring start end)
                                                   rendered-content))))))

  (defun quiescent-render-html-insert-rendered (overlay &optional original-content rendered-content)
    "Insert the rendered content for OVERLAY.

  Optionally supply the original and rendered content, used when
  first created to remember those values."
    (let ((start    (overlay-start overlay))
          (end      (overlay-end   overlay))
          (original (or original-content (overlay-get overlay 'original)))
          (rendered (or rendered-content (overlay-get overlay 'rendered))))
      (delete-overlay overlay)
      (delete-region start end)
      (goto-char start)
      (insert rendered)
      (let ((new-overlay (make-overlay start (+ start (length rendered)))))
        (overlay-put new-overlay 'face      'variable-pitch)
        (overlay-put new-overlay 'evaporate t)
        (overlay-put new-overlay 'original original)
        (overlay-put new-overlay 'rendered rendered)
        (overlay-put new-overlay 'render-html  t)
        (overlay-put new-overlay 'showing-html nil))))

  (defun quiescent-render-html-insert-original (overlay)
    "Insert the original content for OVERLAY."
    (let ((start    (overlay-start overlay))
          (end      (overlay-end   overlay))
          (original (overlay-get   overlay 'original))
          (rendered (overlay-get   overlay 'rendered)))
      (delete-overlay overlay)
      (delete-region start end)
      (goto-char start)
      (insert original)
      (let ((new-overlay (make-overlay start (+ start (length original)))))
        (overlay-put new-overlay 'evaporate t)
        (overlay-put new-overlay 'original original)
        (overlay-put new-overlay 'rendered rendered)
        (overlay-put new-overlay 'render-html  t)
        (overlay-put new-overlay 'showing-html t))))

  (defun quiescent-render-html-post-command-hook ()
    "Reveal the original contents when a point enters rendered blocks."
    (when (and (not (member last-command '(kill-region end-of-buffer)))
               (not (region-active-p)))
      (let ((current-point (point)))
        (progn
          (let ((overlays (quiescent-render-html--overlays (point-min) (point-max))))
            (dolist (overlay overlays)
              (when (and (overlay-get overlay 'showing-html)
                         (or (>= current-point (overlay-end overlay))
                             (<  current-point (overlay-start overlay))))
                (save-excursion (quiescent-render-html-insert-rendered overlay)))))
          (let* ((overlays-here (quiescent-render-html--overlays (point) (point)))
                 (overlay       (car overlays-here)))
            (when (and (not (null overlay))
                       (null (overlay-get overlay 'showing-html)))
              (save-excursion (quiescent-render-html-insert-original overlay))))))))

  (defun quiescent-render-html-unrender-all ()
    "Display source html for all render-able result blocks in this file."
    (interactive)
    (dolist (overlay (quiescent-render-html--overlays (point-min) (point-max)))
      (save-excursion
        (ignore-errors
          (quiescent-render-html-insert-original overlay)))))

  (make-variable-buffer-local 'post-command-hook)
  (make-variable-buffer-local 'before-save-hook)

  (defun quiescent-render-html-register-hook ()
    "Register the post command hook for rendering html."
    (add-hook 'post-command-hook #'quiescent-render-html-post-command-hook)
    (add-hook 'before-save-hook  #'quiescent-render-html-unrender-all))

  (defun quiescent-clear-org-results ()
    "Clear all org results in this buffer."
    (interactive)
    (save-excursion
      (remove-hook 'post-command-hook #'quiescent-render-html-post-command-hook)
      (quiescent-render-html-unrender-all)
      (goto-char (point-min))
      (while (re-search-forward "^#\\+RESULTS:" nil t)
        (beginning-of-line)
        (delete-region (point) (org-babel-result-end)))
      (add-hook 'post-command-hook #'quiescent-render-html-post-command-hook)))
#+END_SRC

Howard Abrams posted a how to on using org mode for literate dev ops.
It's amazingly cool.  Some of the best features I learned about
include the ability to set a property for all of the code blocks under
the current heading with a =:PROPERTY:= drawer.

*** Appearance
Other than the cool stuff which Howard used to accelerate dev ops. he
also had a pretty cool setup for his org mode.  I'm going to try out
two of his suggestions: Large Headings instead of plain text in other
colours and picture bullets instead of many stars.

Org bullets is available from MELPA.  I actually wrote a snippet here
to help write activation hook functions in Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-bullets :lexical t
  (use-package org-bullets
    :straight t
    :config
    (add-hook 'org-mode-hook #'quiescent-activate-org-bullets-mode)
    (defun quiescent-activate-org-bullets-mode ()
      (when (null quiescent-starting-up)
        (org-bullets-mode 1))))
#+END_SRC

=org-beautify-theme= makes all of the headings larger.  It's a theme
so all that's needed is to load it.  This looks awesome and actually
corrected some of the things which I didn't like about =zerodark= in
org mode (such as the weird colour for special block separators).

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-beautify-theme :lexical t
  (use-package org-beautify-theme
      :straight t
      :defer
      :init (when (null (getenv "VIRTUAL_TERMINAL"))
              (load-theme 'org-beautify)))
#+END_SRC

*** Cool Stuff in Howard's Demo
Howard showed an example of running a command on a remote server by
setting the =dir= to a remote directory (adding a property is bound to
=C-c C-x p= and removing a property is bound to =C-c C-x d=):

#+BEGIN_SRC org :lexical t :tangle no
  ,* Install Python Server
    :PROPERTIES:
    :DIR:      /minecraft.howardabrams.com
    :END:

  Here we get the host name from the remote server.  It runs on the
  remote server because we set the =dir= property for all code blocks.

  ,#+BEGIN_SRC sh :lexical t
    hostname --long
  ,#+END_SRC

  Here is the list of currently installed, python-related packages on
  the server:

  ,#+BEGIN_SRC sh :results table :post column1(data=*this*) :lexical t
    sude dpjg --get-selections | grep -v deistall | egrep -i '^python\b'
  ,#+END_SRC

  But the problem with these results is that they're poorly formatted.
  We'll use some =Elisp= to fix it!

  ,#+NAME: column1
  ,#+BEGIN_SRC emacs-lisp :var data="" :results value :lexical t
    (mapcar #'car data)
  ,#+END_SRC
#+END_SRC

Having shown us this awesomeness he then goes on to describe a way of
creating a library from these helper functions which you define in
your org files.  The feature is called "tower-of-babel".  In a tower
file you can specify (in a literate program) helper functions which
you can use elsewhere.

You can add a file to your tower of babel with =C-c C-v i=.

You can also use a persistent session to a server to eliminate the
overhead of always connecting.  This is done with a =:session:=
property which can, again, be set as a property.  You can view the
session itself by switching to the buffer by that name.

The final thing he shows is how to use multiple hops in the connection
for TRAMP.  Here's the syntax:

=/ssh:<first-host>|<second-host>|<dest-host>:<path-to-file>=

*** Enforcing Dependencies
It's possible to get org mode to prevent you from working on things
down the line first.  All that you have to do is add the property
=:ORDERED= as =t= to a parent task and it will force the sub tasks to
be ordered.  To add a property to a sub tree all you need is: =M-x
org-property-action=.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-dependencies :lexical t
  (setq org-enforce-todo-dependencies t)
#+END_SRC

*** Reveal
You can export org documents to RevealJS presentations.  It's a very
simple way of doing things but it lets you be productive.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-reveal :lexical t
  (use-package ox-reveal
      :straight t
      :demand t)

  (require 'url)

  (defun quiescent-download-reveal-js-here ()
    "Download the reveal source file here."
    (interactive)
    (progn
      (url-copy-file "https://github.com/hakimel/reveal.js/archive/3.9.2.tar.gz" "reveal.js-3.9.2.tar.gz")
      (shell-command "tar -xzvf reveal.js-3.9.2.tar.gz")
      (shell-command "mv reveal.js-3.9.2/ reveal.js")))
#+END_SRC

*** Secretaria
There's a package on Melpa which aims to help you keep track of what
you're doing.  It does so by reminding you of your clocked in task and
saving your clocked in task so that it can let you know about it when
you restart Emacs.  I think that it'll help me to keep track of
things.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref secretaria :lexical t
  (use-package secretaria
    :straight t)

  (copy-face 'fringe 'quiescent-alert-saved-fringe-face)

  (defun quiescent-alert-fringe-notify (info)
    (progn
      (set-face-background 'fringe (cdr (assq (plist-get info :severity)
                                              alert-severity-colors)))
      (message "%s" (plist-get info :message))))

  (defun quiescent-alert-fringe-restore (_info)
    (copy-face 'quiescent-alert-saved-fringe-face 'fringe))

  (alert-define-style 'fringe-message :title "Change the fringe color"
                      :notifier #'quiescent-alert-fringe-notify
                      :remover #'quiescent-alert-fringe-restore)
#+end_src

*** Org Brain
There's an interesting approach to note taking and exploration which
uses implicit edges between nodes in a hierarchy to create an
explore-able web of information.  "The Brain" was the first piece of
software to implement the idea.  Org Brain is Emacs' equivalent of
that software.  I'm going to give it a go as a story mind-mapping
tool.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref org-brain :lexical t
  (use-package org-brain
    :straight t
    :init
    (setq org-brain-path "~/org/brain")
    :config
    (require 'org-capture)
    (bind-key "C-c b" 'org-brain-prefix-map org-mode-map)
    (setq org-id-track-globally t)
    (setq org-id-locations-file "~/.emacs.d/.org-id-locations")
    (add-hook 'before-save-hook #'org-brain-ensure-ids-in-buffer)
    (push '("b" "Brain" plain (function org-brain-goto-end)
            "* %i%?" :empty-lines 1)
          org-capture-templates)
    (setq org-brain-visualize-default-choices 'all)
    (setq org-brain-title-max-length 12)
    (setq org-brain-include-file-entries nil
          org-brain-file-entries-use-title nil))
#+end_src

*** Org Pomodoro
The Pomodoro technique is a method of maximizing productivity by
engaging in shorter spans of concentration and then giving your brain
a break regularly.  I'm interested in trying it out, and, of course,
Emacs has a package for it.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref org-pomodoro :lexical t
  (use-package org-pomodoro
    :straight t
    :custom (org-pomodoro-length 25))
#+end_src

** Htmlize
Org mode can export to HTML with source code highlighting.  You need
the Htmlize package to do it though.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref htmlize :lexical t
  (use-package htmlize
      :straight t)
#+END_SRC

** EPresent
Epresent is a mode designed to enable presentations to be given from
org mode files.  The idea is that you simply open an org file and call
Epresent.  There are built in bindings to do the following (from the
github README):

 - Call epresent-run on an org-buffer.
 - press t / 1 to view the top level of the presentation
 - navigate the presentation with n/f, p/b
 - scroll with k and l
 - use c and C to navigate between code blocks, e to edit them, x to
   make it run, and s / S to toggle their visibility
 - quit with q

I've decided to use it for a lightning talk I'm giving on Emacs.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref epresent :lexical t
  (use-package epresent
   :straight t)

  (defun outline-hide-body ()
    "I think that epresent expects this function to be here.

  I suspect that it was part of old org mode."
    (hide-body))

  (defface epresent-date-face
    '((t :weight bold :height 270 :underline t :inherit variable-pitch))
    "I think that epresent also expects this face to be there."
    :group  'epresent)

  (defun quiescent-epresent-toggle-hide-src-blocks ()
    "Run `epresent-toggle-hide-src-blocks'."
    (when (null quiescent-starting-up)
      (epresent-toggle-hide-src-blocks)))

  (add-hook 'epresent-mode-hook
         #'quiescent-epresent-toggle-hide-src-blocks)

  (when quiescent-macbook
    (advice-add 'epresent-quit :around
          #'quiescent-inhibit-frame-deletion))
#+END_SRC

** Demo IT
I recently decided that demos of code are far to difficult to get
right every time and that there must be a better way.  Also I saw
Howard Abrams doing demos of code with style so I investigated and
discovered that he wrote a package for automating this kind of thing.

It's called "Demo It" and the idea is that one should be able to
script the steps of a demo and then just hit space a whole bunch of
times and step through code writing itself alongside a nice org
document.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref demo-it :lexical t
  (use-package demo-it
   :straight t)
#+END_SRC

Demo it needs org-tree-slide in order to make your demonstration flick
between slides in the org buffer.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-tree-slide :lexical t
  (use-package org-tree-slide
   :straight t)
#+END_SRC

** Magit Mode
Magit is a system which integrates tightly with Git and the built in
VC commands of Emacs to provide a super cool interface to using Git
for version control.

I had to force magit to ask for passwords using an environment
variable so that I could connect to repositories over HTTPS.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref magit-setup :lexical t
  (use-package magit
    :straight t
    :custom (magit-diff-refine-hunk t)
    :config
    (progn
      (setenv "GIT_ASKPASS" "git-gui--askpass")
      (global-set-key (kbd "C-c m") #'magit-status)))
#+END_SRC

I often create commit messages which note the change per file.
Instead of writing it out every time I'm creating a hook to add it in.
It turns out that the Magit editor pops up asynchronously.  This is a
problem for me because there's no hook either and it runs text mode
:/.  Instead I've made this command interactive.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref magit-insert-files :lexical t
  (defun quiescent-insert-files-for-commit-message (&rest _)
    "Insert the files in the changes to be commited section of the magit commit message buffer."
    (interactive)
    (progn
      (insert "\n\n")
      (while (quiescent-copy-next-file-to-here)
        (insert "\n"))
      (goto-char (point-min))))

  (defun quiescent-copy-next-file-to-here ()
    "Copy the next file in changes to be committed to point."
    (let (found-it)
      (save-excursion
        (when (re-search-forward "modified: +src/")
          (when (save-excursion
                  (not (ignore-errors
                         (re-search-backward "Changes not staged for commit:"))))
            (backward-word)
            (kill-line)
            (setq found-it t))))
      (yank)
      found-it))
#+END_SRC

** Abridge Diff
   I often find that I edit files which contain long lines.  Those
   lines might be images, for example.  When it comes to diffing those
   files it becomes difficult to see what's changed and can also cause
   Emacs to grind to a halt as it tries to render those lines.  Enter
   ~abridge-diff~, a package which promises to provide summaries of
   those diffs.

   #+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref abridge-diff :lexical t
     (use-package abridge-diff
       :straight t
       :after magit ;; optional, if you'd like to use with magit
       :init (abridge-diff-mode 1))
   #+end_src

** Git Commands
I've added a few commands which I intend to use in eshell to make
things a bit easier.  I'll alias them as I go.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref git-commands :lexical t
  (require 'vc-git)

  (defun quiescent-current-branch-name ()
    "Produce the current branch name."
    (car (vc-git-branches)))

  (defun quiescent-insert-current-branch-name ()
    "Print the current branch name at point."
    (interactive)
    (insert (quiescent-current-branch-name)))

  (require 'esh-mode)

  (defun quiescent-add-insert-branch-binding-eshell ()
    "Add the insert branch binding in eshell mode."
    (when (null quiescent-starting-up)
      (define-key eshell-mode-map (kbd "C-c b") #'quiescent-insert-current-branch-name)))

  (add-hook 'eshell-mode-hook #'quiescent-add-insert-branch-binding-eshell)

  (defconst q-git-log-entry-parse-up-to-extra-details ".*Author: \\(.*\\)\nDate:   \\(.*\\)\n\n    \\(.*\\)$"
    "A regular expression for parsing git log entries.")

  (defconst q-git-month-translation-alist '(("Jan" . "01")
                                            ("Feb" . "02")
                                            ("Mar" . "03")
                                            ("Apr" . "04")
                                            ("May" . "05")
                                            ("Jun" . "06")
                                            ("Jul" . "07")
                                            ("Aug" . "08")
                                            ("Sep" . "09")
                                            ("Oct" . "10")
                                            ("Nov" . "11")
                                            ("Dec" . "12"))
    "A transaltion alist for string months to ints.")

  (defun q-git-to-org-time-stamp (git-time-stamp)
    "Convert GIT-TIME-STAMP into org format for time stamps."
    (cl-labels ((month-to-int (month)
                              (cdr (assoc month q-git-month-translation-alist))))
      (pcase (split-string git-time-stamp " " t)
        (`(,_ ,month ,day ,time ,year ,_)
         (format "%s-%s-%02d %s" year (month-to-int month) (string-to-number day) time)))))

  (defun q-git-parse-log-entry (log-entry-text)
    "Parse LOG-ENTRY-TEXT into a list structure."
    (progn
      (string-match q-git-log-entry-parse-up-to-extra-details log-entry-text)
      (let ((author  (substring log-entry-text (match-beginning 1) (match-end 1)))
            (date    (substring log-entry-text (match-beginning 2) (match-end 2)))
            (summary (substring log-entry-text (match-beginning 3) (match-end 3)))
            (detail  (substring log-entry-text (match-end 3))))
        `(GIT-LOG ,author ,(q-git-to-org-time-stamp  date) ,summary ,detail))))

  (defun q-git-parse-log (log-lines)
    "Parse LOG-LINES into a list of list structures."
    (mapcar #'q-git-parse-log-entry (split-string log-lines "^commit" t "[ \n]")))

  (defun q-grab-match (regex string &optional match-group)
    "Match REGEX to STRING and then produce the matching text.
  If MATCH-GROUP is supplied then produce that matching group."
    (progn
      (when (null match-group)
        (setq match-group 0))
      (when (string-match regex string)
        (substring string (match-beginning match-group) (match-end match-group)))))

  (defun q-push-hash (key value table)
    "Define KEY to be a list updated with VALUE from the current list in TABLE.

  Creates a list with only value in it if there isn't one yet."
    (puthash key (append (list value) (gethash key table)) table))

  (defvar *q-git-augment-task* #'identity
    "A function to augment a task entry when grouping by commiter then task.")

  (defun q-parse-string-field-by-regexp (regexp)
    "Parse a string field from the current buffer using the first hit of REGEXP."
    (q-grab-match regexp
                  (buffer-string)
                  1))

  (defvar *q-git-report-buffer* "*git-report*"
    "The name of the buffer to wirte the report to.")

  (defvar *q-git-grouping-function* #'q-git-group-by-commiter-then-task
    "The function which will perform grouping prior to writing the report.")
  (defvar *q-git-printing-function* #'identity
    "The function which will print the report.
  Must be compatible with the output of the grouping function.")

  (defvar quiescent-patch-file-buffer-name "*patch-files*"
    "The name of buffer to create a patch files in.")

  (defun quiescent-bad-commit-message (patch-file-path)
    "Produce a list of the lines where bad commits are found.

  Search the file at PATCH-FILE-PATH for the invalid messages."
    (with-temp-buffer
      (let (start
            end
            bad)
        (insert-file-contents patch-file-path)
        (while (re-search-forward "Subject: \\[PATCH\\( [0-9]+/[0-9]+\\|\\)\\] " nil t nil)
          (progn
            (setq start (point))
            (setq end   (re-search-forward "^---$"))
            (narrow-to-region start end)
            (goto-char (point-min))
            (unfill-paragraph)
            (when (re-search-forward ".\\{79\\}" nil t nil)
              (widen)
              (push (line-number-at-pos) bad))
            (widen)))
        bad)))

  (defun quiescent-bad-commits-for-patches-in-dir (dir)
    "Produce a patches in DIR which have bad commit messages.

  A bad commit is defined as having more than 78 characters in any
  of it's lines."
    (interactive "DDirectory: ")
    (let ((patch-files (directory-files dir nil "\\.patch$" t)))
      (progn
        (switch-to-buffer quiescent-patch-file-buffer-name)
        (erase-buffer)
        (dolist (patch-file patch-files)
          (let ((bad-lines (quiescent-bad-commit-message patch-file)))
            (when bad-lines
              (insert patch-file "\n - " (mapconcat #'number-to-string bad-lines "\n - ") "\n")))))))

  (defun quiescent-parse-month (month)
    "Parse MONTH into it's integer representation."
    (pcase (downcase month)
      ("jan" 1)
      ("feb" 2)
      ("mar" 3)
      ("apr" 4)
      ("may" 5)
      ("jun" 6)
      ("jul" 7)
      ("aug" 8)
      ("sep" 9)
      ("oct" 10)
      ("nov" 11)
      ("dec" 12)))

  (defun quiescent-parse-git-time-string (s)
    "Parse S into an EMACS time list (SEC MINUTE HOUR DAY MONTH YEAR DOW DST UTCOFF)."
    (pcase (split-string s " " t)
      (`(,_ ,month ,day ,_ ,year)
       `(0 0 0 ,(string-to-number day) ,(quiescent-parse-month month) ,(string-to-number year) 0 nil 0))))

  (use-package git-timemachine
    :straight t)

#+END_SRC

** Chess
I downloaded and setup a chess mode for fun and for passing time while
waiting for things which are blocking me.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref chess :lexical t
  (use-package chess
      :straight t)
#+END_SRC

** Typing Game
This is quite cool.  There's a typing game on the EMACS package
archives which is inspired by typing of the dead.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref typing-game :lexical t
  (use-package typing
      :straight t)
#+END_SRC

** Slock
Slock is a program which will lock the screen.  You just need to enter
your password to unlock it.  While it's locked it'll show plain
colours on your screens.  Since I'm using Emacs as my window manager
at work I'll need to be able to lock my PC from Emacs so I'm going to
create a command to do that.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref slock :lexical t
  (defun quiescent-lock-pc ()
    "Lock this computer.

  Enter the password for this account to unlock it."
    (interactive)
    (start-process "slock" "*slock-buffer*" "slock"))
#+END_SRC

** Tramp
Tramp is a system which allows Emacs to behave as though it were
running on a remote system.  It makes working on remote servers
amazing because you can edit files with local latency and then
synchronise them back to the server when you're ready.

Tramp has built in support for most network protocols.  I recently
discovered that it also has support for connecting to Docker.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref tramp :lexical t
  (use-package docker-tramp
      :straight t)
#+END_SRC

** Gnu Plot
Emacs can drive gnuplot and this functionality can be integrated to
org mode :) I'm using it to do plots in academic documents right now
but the possibilities are limitless.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref gnuplot :lexical t
  (use-package gnuplot
    :straight t)
#+END_SRC

** 4Clojure
4Clojure is a website which provides challenges for hackers who want
to practice programming in Clojure.  Incidentally there's an Emacs
client for that ;)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref 4clojure :lexical t
  (use-package 4clojure
    :straight t)

  <<4clojure-convenience>>
  <<track-4clojure-progress>>
  <<4clojure-correct-number>>
  <<4clojure-pickup>>
#+END_SRC

After trying one out I was alarmed to find that the this package
doesn't help you to track progress and that you have to M-x all the
things to get the questions answered and move onto the next question.

Artur Malabarba to the rescue!  The following makes answering
questions with this interface much more convenient.  Now I can answer
the question at the end of the buffer and hit M-j to answer and
progress.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref 4clojure-convenience :lexical t
  (defun quiescent-backward-up-list-w/o-errors ()
    "Move backward up list once without errors."
    (condition-case nil
        (progn
          (backward-up-list)
          t)
      (error nil)))

  (defun quiescent-escape-all-sexps ()
    "Move the point up out of every sexp until it's not contained by any."
    (interactive)
    (while (quiescent-backward-up-list-w/o-errors)))

  (defun endless/4clojure-check-and-proceed (&rest _)
    "Check the answer and show the next question if it worked."
    (interactive)
    (if
        (save-excursion
          ;; Find last sexp (the answer).
          (goto-char (point-min))
          (while (search-forward "__" nil t))
          (quiescent-escape-all-sexps)
          (forward-list)
          ;; Check the answer.
          (let ((answer
                 (buffer-substring (point) (point-max)))
                ;; Preserve buffer contents, in case you failed.
                (orig-buffer (buffer-string)))
            (goto-char (point-min))
            (while (search-forward "__" nil t)
              (when (not (quiescent-inside-comment-p))
                (replace-match answer)))
            (prog1
                (string-match "failed." (4clojure-check-answers))
              (erase-buffer)
              (insert orig-buffer))))
        (message "Failed :(")
      (4clojure-next-question)))

  (defun endless-4clojure-new-problem (&rest _)
    (progn
      ;; Prettify the 4clojure buffer.
      (goto-char (point-min))
      (forward-line 2)
      (forward-char 3)
      (fill-paragraph)
      ;; Position point for the answer
      (goto-char (point-max))
      (insert "\n\n\n")
      (forward-char -1)
      ;; Define our key.
      (local-set-key (kbd "M-j") #'endless/4clojure-check-and-proceed)))

  (advice-add #'4clojure/start-new-problem :after #'endless-4clojure-new-problem)
  (advice-add #'endless/4clojure-check-and-proceed :before #'save-some-buffers)
#+END_SRC

There's only one piece of the puzzle missing though, because I don't
have a way of tracking progress with this.  So, how about adding
advice to the advice which saves the current buffer to a configurable
answers directory (!)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref track-4clojure-progress :lexical t
  (defvar quiescent-4clojure-answer-directory "~/.emacs.d/4clojure-answers/"
    "A directory where the answers to 4clojure questions should be answered.")

  (defun quiescent-4clojure-save-answer (&rest _)
    "Save the current buffer as a solution to a 4clojure problem."
    (write-file (replace-regexp-in-string
                 "\\*" ""
                 (concat quiescent-4clojure-answer-directory (buffer-name) ".clj"))))

  (advice-add #'4clojure/start-new-problem :after #'quiescent-4clojure-save-answer)
#+END_SRC

One last problem is that the 4clojure library uses the buffer name to
figure out what question you're answering.  The number is used to make
a REST call to check the answer.  I'll have to modify that to work
with my changes to the buffer name.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref 4clojure-correct-number :lexical t
  (defun quiescent-4clojure-problem-number-from-name (buffer-name)
    "Produce the problem number part of BUFFER-NAME."
    (string-to-number
     (car
      (last
       (split-string
        (file-name-sans-extension
         (file-name-nondirectory
          buffer-name))
        "-")))))

  (defun 4clojure/problem-number-of-current-buffer ()
    "Gets the problem number of the current buffer or 0 if current buffer isn't
  named something like *blah-blah-123*"
    (quiescent-4clojure-problem-number-from-name (buffer-name (current-buffer))))
#+END_SRC

Another feature which I'm interested in having here is being able to
pick up where I left off from.  All I need to do is find the latest
question answered in the question answers directory and add one to the
question number!

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref 4clojure-pickup :lexical t
  (defun quiescent-4clojure-problems-done ()
    "Produce a list of the problem numbers which I've completed on 4clojure."
    (mapcar (lambda (file-name) (quiescent-4clojure-problem-number-from-name file-name))
            (directory-files quiescent-4clojure-answer-directory nil nil t)))

  (defun quiescent-4clojure-max-problem-number ()
    "Produce the highest problem number I've solved in 4clojure."
    (apply #'max (quiescent-4clojure-problems-done)))

  (defun quiescent-4clojure-pickup ()
    (interactive)
    "Pickup from where I left off with 4clojure problems."
    (4clojure-open-question (number-to-string (1+ (quiescent-4clojure-max-problem-number)))))
#+END_SRC

This works, but there's a lot of noise when I solve one due to all the
moving around and marking which happens to isolate the solution.  The
solution to that is to suppress message while I'm finding the
solution.  I should also make the buffers save without user input,
because that's a bit irritating atm.

**** TODO Silence Messages While Finding the Solution

**** TODO Save Buffers Without Prompting the User

** ERC
Emacs comes with it's own IRC client which is pretty darn good and
gets updates all of the time.  I'm going to see whether I can use it
to connect to the Clojure channel on zatech.slack.com.  I actually
don't think that I'll need any config to get started with this so here
goes!  (=M-x erc=)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref erc :lexical t
  ;; Courtesy to the Emacs wiki for this: https://www.emacswiki.org/emacs/ErcSSL

  (require 'tls)

  (defun start-irc ()
    "Connect to IRC."
    (interactive)
    (erc-tls :server "zatech.irc.slack.com" :port 6697
             :nick "TODO" :password "TODO")
    (setq erc-autojoin-channels-alist '(("zatech.slack.com" "#clojure"))))
#+END_SRC

For reference:
Host: zatech.irc.slack.com
User: TODO

** BBDB
BBDB is the Big Brother insidious DataBase for Emacs.  It's a database
of contact details which people mostly use for storing and auto
completing email addresses in an email client.

I decided to start using it because I always have to look up email
addresses and that's a bit of a pain and a bit of an embarrassment
given the level of Emacs Fu to which I claimed to have reached.  So
here goes.  I chose the very first link which Google spat out at me
and followed the guidance of some unknown soul on the Internet.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref bbdb :lexical t
  (use-package bbdb
    :straight t
    :defer 10
    :config (progn
              (setq bbdb-file "~/.emacs.d/bbdb"
                    bbdb-mua-auto-update-p 'query)
              (bbdb-initialize 'gnus 'message)
              (bbdb-mua-auto-update-init 'message)))
#+END_SRC

** Rest Client
Emacs has a rest client.  I'm going to be working with micro services
soon so I think that it could be totally awesome to create requests in
Emacs and potentially even share them with my team (!)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref rest-client :lexical t
  (use-package restclient
   :straight t
   :config (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
#+END_SRC

** Linkd
I recently came across =highlight.el= and found that it uses
=linkd.el= to make it's documentation interactive and search-able in
the package interface.  To see how it works just =M-x list-packages
RET= and find the entry on highlight.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref linkd :lexical t
  (require 'wiki/linkd)
#+END_SRC

** CalcTex
[[Github.com]] recently added a feature (or they always had it and I had
no idea) where you it shows you repositories which you might be
interested in.  Recently it pointed me at some Emacs Lisp so naturally
I was very interested.  The repository was called CalcTex and it's
basically a WYSIWIG editor for LaTeX equations with built in support
for ~calc-mode~ which is the Emacs symbolic calculator.  I find this
idea very appealing so I'm adding it here with the intention of
showing it off to people soon.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref calctex :exports none :lexical t
  (eval-and-compile
    (add-to-list 'load-path "~/.emacs.d/lisp/calctex/")
    (require 'calctex))
#+END_SRC

** Excorporate
It turns out that you can read your Outlook email from Emacs instead
of using the horrible web interface which takes ages to load and can't
find anything at all.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref excorporate :exports none :lexical t
  (use-package excorporate
      :straight t)
#+END_SRC

** Taking Screenshots
When Reddit is nice, it's awesome!  I found a package that someone
wrote which can take screenshots of text to share with others.  It'll
handle margins well and add a drop frame too!

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref screenshot :exports none :lexical t
  (use-package posframe
    :straight t)

  (eval-and-compile
    (add-to-list 'load-path "~/.emacs.d/lisp/screenshot")
    (require 'screenshot))
#+end_src

** Email
I recently decided to setup ~mbsync~ and ~mu4e~ because I don't like
having to log into Google in my web browser all the time.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref mu4e :exports none :lexical t
  (eval-and-compile
    (when (directory-empty-p "/opt/mu/mu4e")
     (add-to-list 'load-path "/opt/mu/mu4e")
     (require 'mu4e)))

  (with-eval-after-load 'mu4e
    (setq mu4e-sent-folder   "/[Gmail]/Sent Mail"
          mu4e-trash-folder  "/[Gmail]/Bin"
          smtpmail-smtp-user "example@gmail.com"
          mu4e-get-mail-command "mbsync gmail"
          ;; get emails and index every 5 minutes
          mu4e-update-interval 300
          ;; send emails with format=flowed
          mu4e-compose-format-flowed t
          ;; don't need to run cleanup after indexing for gmail
          mu4e-index-cleanup nil
          mu4e-index-lazy-check t
          ;; more sensible date format
          mu4e-headers-date-format "%d.%m.%y"))
#+end_src

* Writing Natural Language
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref writing-natural-language :exports none :lexical t
  <<ia-writer>>
  <<auctex>>
  <<editing>>
  <<ispell>>
  <<langtool>>
  <<pdf-tools>>
  <<fill-unfill-paragraph>>
#+END_SRC

Emacs can be used for much more than just writing code and interacting
with complicated Linux programs.  (It is afterall an *editor*.)  One
of Emacs's strengths is writing documents and markup languages for
natural language.

** iA Writer Mode
iA writer is an editor for writers to get a distraction-free writing
experience.  It looks great, to be honest, and a bunch of people have
made modifications to their Emacs to be more like the it.  I'm
creating a minor mode to replicate their work in Emacs and then I'm
going to build up on it.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref ia-writer :lexical t
  (require 'cl-lib)

  (use-package writeroom-mode
    :straight t)

  (defvar ia-writer-highlight-current-sentance-delay 0.1
    "The number of seconds to wait before highlighting the current sentance.")

  (define-minor-mode ia-writer-mode
    "An 'iA Writer' like mode."
    :init-value nil
    :lighter " iA Writer"
    :keymap nil
    :group 'ia-writer
    (if ia-writer-mode
        (progn
          (writeroom-mode 1)
          (blink-cursor-mode -1)
          (visible-mark-mode -1)
          (auto-fill-mode 1)
          (run-at-time ia-writer-highlight-current-sentance-delay
                       nil
                       (ia-writer-highlight-current-sentance-on-idle-timer-exirey
                        (current-buffer))))
      (progn
        (writeroom-mode -1)
        (blink-cursor-mode 1)
        (visible-mark-mode 1)
        (auto-fill-mode -1)
        (mapc #'delete-overlay (ia-writer--overlays)))))

  (defun ia-writer--overlays ()
    "Get the overlays in the current buffer which are used by `ia-writer-mode'."
    (cl-remove-if-not (lambda (overlay) (overlay-get overlay 'hidden))
                      (overlays-in (point-min) (point-max))))

  (defvar ia-writer-hidden-font-colour "#666168"
    "The colour of the font which should fade into the background.")

  (defun ia-writer-set-light-mode ()
    "Set the background colour of the overlays for a light-mode theme."
    (interactive)
    (setq ia-writer-hidden-font-colour "#e1dfe1"))

  (defun ia-writer-highlight-current-sentance-on-idle-timer-exirey (buffer)
    "Highlight the at point when the idle timer expires.

    BUFFER is the buffer to do the highlighting in.  If that buffer
    is gone or doesn't have the right mode then cancel the timer."
    (lambda () (when (buffer-live-p buffer)
                 (with-current-buffer buffer
                   (when ia-writer-mode
                     (let* ((start    (save-excursion (backward-sentence) (point)))
                            (end      (save-excursion (ignore-errors (forward-sentence))  (point)))
                            (overlays (ia-writer--overlays))
                            (first    (or (and overlays (move-overlay (car overlays) (point-min) start))
                                          (make-overlay (point-min) start)))
                            (second   (or (and overlays (move-overlay (cadr overlays) end (point-max)))
                                          (make-overlay end         (point-max)))))
                       (when (not overlays)
                         (overlay-put first  'hidden t)
                         (overlay-put first  'face   `(:foreground ,ia-writer-hidden-font-colour))
                         (overlay-put second 'hidden t)
                         (overlay-put second 'face  `(:foreground ,ia-writer-hidden-font-colour))))
                     (run-at-time ia-writer-highlight-current-sentance-delay
                                  nil
                                  (ia-writer-highlight-current-sentance-on-idle-timer-exirey buffer)))))))
#+END_SRC

** LaTeX
Prof. Gibbon (AKA comrade Gibbon.) descriptions of electrons as sheep
and controversial discussions of politics, religion and all other
things designed to get fresh first years thinking about the world made
him well known among the EE Students at Wits.  One principle that he
taught his students and which resonated with me is to "arrive never,
rather than late."  Another is (which I'm very happy about) is LaTeX.

Apparently named after a German tank, this typesetting language makes
Microsoft Word look like a child's play thing.  Gone are the missing
features and the incorrectly typeset pages.  Gone are the images which
just don't go in the right place and the endless context menus where
you just can't find what you were looking for...  =:)=

I like to use custom stuff in my LaTeX files, like non standard
fonts.  This requires that either XeTeX or LuaTeX be used instead of
pdfTeX.  I chose LuaTeX a while ago and I've kinda stuck with it.

The best mode for editing LaTeX files in Emacs is AucTeX.  Aside from
changing the font lock settings does a number of other things to
integrate more tightly with LaTeX.  It doesn't provide itself so
instead I check whether it installed first and then install it if it's
not installed.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref auctex :lexical t
  (require 'ox-latex)

  (setq TeX-engine 'default)
  (setq org-latex-listings t)

  (ignore-errors
    (unless (package-installed-p 'auctex)
      (list-packages)
      (package-install 'auctex)))

  (defun quiescent-disable-yas-minor-mode ()
    "Disable YAS minor mode."
    (yas-minor-mode -1))

  (setq TeX-view-program-selection
        '(((output-dvi has-no-display-manager)
           "dvi2tty")
          ((output-dvi style-pstricks)
           "dvips and gv")
          (output-dvi "xdvi")
          (output-pdf "EmacsClient")
          (output-html "xdg-open")))

  (setq TeX-view-program-list '(("EmacsClient" "emacsclient %o")))

  (defun quiescent-export-org-to-pdf-via-latex-asynch ()
    "Export the current document to a PDF via LaTeX asynchronously."
    (interactive)
    (org-latex-export-to-pdf t))

  (define-key org-mode-map (kbd "s-e") #'quiescent-export-org-to-pdf-via-latex-asynch)
#+END_SRC

** Editing Text
There are plenty of hacks for editing text available on the internet
and on the Emacs wiki.  I intend to aggregate them here.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref editing :lexical t
  ;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
  (defun unfill-paragraph (&optional region)
    "Unfill REGION, otherwise paragraph at point.

  i.e. the reverse of fill paragraph."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

  ;; Handy key definition
  (define-key global-map "\M-Q" 'unfill-paragraph)
#+END_SRC

** Fly Spell
Emacs comes with an interactive spell checking system called
Flyspell.  I've chosen to enable it in Bibtex, text and TeX/LaTeX
modes.  I usually use aspell as the local system binary for performing
the actual spell checks and use the standard British dictionary.

**** TODO Migrate Settings out of customise and to here for flyspell

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref ispell :lexical t
  (use-package flyspell
    :init (progn
            (setq ispell-dictionary "british")
            (setq ispell-program-name "aspell"))
    :config
    (progn
      (defun quiescent-turn-on-flyspell ()
        "Turn on `flyspell'."
        (when (null quiescent-starting-up)
          (turn-on-flyspell)))
      (define-key flyspell-mode-map (kbd "C-.") nil)
      (add-hook 'text-mode-hook   #'quiescent-turn-on-flyspell)
      (add-hook 'bibtex-mode-hook #'quiescent-turn-on-flyspell)
      (add-hook 'LaTeX-mode-hook  #'quiescent-turn-on-flyspell)
      (add-hook 'TeX-mode-hook    #'quiescent-turn-on-flyspell)))
#+END_SRC

** Langtool
I recently found a tool online which allows one to perform grammar
checking.  The commands for invoking it can be found at the prefix
=langtool-=.  It's designed to be used non-interactively, so I should
invoke it in order to check the grammar of what I'm writing.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref langtool :lexical t
  (use-package langtool
      :straight t
      :config (progn
                (setq langtool-default-language "en-GB")
                (when quiescent-macbook
                  (setq langtool-language-tool-jar
                        "/opt/langtool/languagetool-commandline.jar"))))
#+END_SRC

** PDF Tools
Emacs has built in support for pre-rendering a PDF document and then
displaying images corresponding to the pages of the PDF in a buffer.
This approach leaves a bit to be desired.  It's a bit slow, the
quality of the rendered PDF isn't all that great and it's just an
image.  It not being an image is a problem because you can't isearch
through an image.  It's for these reasons that I usually don't view
PDFs in Emacs.

Recently, though, Henry made me aware of a package called PDF tools.
It's great because it renders the pages of a PDF on demand and
supports richer features.  Such as searching, occur and more.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref pdf-tools :lexical t
  (defvar install-pdf-tools
    '(use-package pdf-tools
       :straight t
       :hook (pdf-view-mode . quiescent-disable-composable-mode)
       :demand t
       :config (progn
                 (define-key pdf-view-mode-map (kbd "M-w") #'pdf-view-kill-ring-save)
                 (pdf-tools-install))))

  (eval install-pdf-tools)

  (defun quiescent-disable-composable-mode ()
    "Disable composable mode."
    (when (null quiescent-starting-up)
      (progn
     (composable-mode -1)
     (composable-mark-mode -1))))
#+END_SRC

** Editing Writing
I often switch between writing a story and then editing it with
Grammarly.  When I write stories in Emacs then I like to keep the
paragraphs formatted to the built in width rules with
~fill-paragraph~, and when I switch across to Grammarly it likes the
paragraphs to be written in the more modern style: where line breaks
are only used in between paragraphs.

I've written to functions which enable you to go to and from those
formats as follows:

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref fill-unfill-paragraph :lexical t
  (defmacro quiescent-for-all-paragraphs (&rest body)
    "Execute BODY with the point in each paragraph in the current buffer."
    `(save-excursion
       (goto-char (point-min))
       (while (not (eq (point) (point-max)))
         (ignore-errors
           ,@body
           (forward-paragraph)))))

  (defun quiescent-fill-all-paragraphs ()
    "Run `fill-paragraph' on all paragraphs in the current document."
    (interactive)
    (quiescent-for-all-paragraphs (fill-paragraph)))

  (defun quiescent-unfill-all-paragraphs ()
    "Run `unfill-paragraph' on all paragraphs in the current document."
    (interactive)
    (quiescent-for-all-paragraphs (unfill-paragraph)))
#+END_SRC

* Controlling Emacs
These are the bindings which I've added to make working with Emacs,
it's frames and it's windows faster.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref controlling-emacs :lexical t
  (defun quiescent-close-help ()
    "Close the help window."
    (interactive)
    (let ((original-window (selected-window)))
      (cl-loop
         for window being the windows
         when (equal "*Help*" (buffer-name (window-buffer window)))
           do (select-window window)
              (call-interactively #'quit-window))
      (select-window original-window)))

  (global-set-key (kbd "C-c f") #'make-frame)
  (global-set-key (kbd "C-c B") #'browse-url-at-point)
  (global-set-key (kbd "s-o")   #'other-frame)
  (global-set-key (kbd "s-q")   #'quiescent-close-help)

  (key-chord-define-global "x0" #'delete-window)
  (key-chord-define-global "x1" #'delete-other-windows)
  (key-chord-define-global "x2" #'split-window-below)
  (key-chord-define-global "x3" #'split-window-right)
#+END_SRC

Emacs is controllable via the same system of key bindings as is used
for programing etc.  For instance you can split windows, create new
frames, fullscreen etc.

* Library Additions to Emacs
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref library-additions-to-emacs :exports none :lexical t
  <<async>>
#+END_SRC

Because Emacs is extensible it's possible to extend the features of
the editor and the Emacs Lisp language.  In this section we list such
modifications.

** Async
Some of the things that I've been hacking into Emacs lately take a lot
of time to process.  I can't have these blocking the main thread
because that would prevent me from getting on with stuff.

The first code I've written which requires this is my function to
parse the whole of a project.  This takes ages but will help me to
speed up my interaction with large projects.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref async :lexical t
  (use-package async
      :straight t)
#+END_SRC

** GCMH
The Garbage Collector Magic Hack is to try to only do garbage
collection while the system is idle.  If you can manage this then
longer running tasks will run with far less garbage collection.  Since
user interaction is the main axis of computation in Emacs it seems
reasonable that this will just be a good improvement overall.

I've turned it off because I've encountered very long pauses recently
and I think that they may be massive GC pauses.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref gcmh :lexical t
  (use-package gcmh
    :straight t
    :demand t
    :config (gcmh-mode 1))
#+end_src

* The Appearance of Emacs
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref the-appearance-of-emacs :exports none :lexical t
  <<themes>>
  <<prism>>
  <<page-break-lines>>
  <<prettify>>
  <<splash-screen>>
  <<mb-depth>>
  <<agenda-margins>>
  <<xhair>>
#+END_SRC

Emacs has support for themes.  One may design a theme and have it
loaded to change the look and feel of Emacs.  I discovered the Ample
theme on the Melpa repository and I think it's pretty cool.  I'm a fan
of having a dark background so I enabled the dark theme.

Since writing this paragraph I've switched from Ample to Zerodark (by
Peton) and then to Doom-Themes.  Doom Themes are the best designed
themes I've used.  They have great coverage of Emacs features, a great
mode line and they're reasonably efficient.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref themes :lexical t
  (use-package doom-themes
      :straight t
      :config (progn
                ;; Global settings (defaults)
                (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
                      doom-themes-enable-italic t) ; if nil, italics is universally disabled

                ;; Enable flashing mode-line on errors
                (doom-themes-visual-bell-config)

                ;; Enable custom neotree theme (all-the-icons must be installed!)
                (doom-themes-neotree-config)
                ;; or for treemacs users
                (doom-themes-treemacs-config)

                ;; Corrects (and improves) org-mode's native fontification.
                (doom-themes-org-config)

                (defun quiescent-load-dark-theme ()
                  "Load my dark theme."
                  (interactive)
                  (load-theme 'doom-one t))

                (defun quiescent-load-light-theme ()
                  "Load my light theme."
                  (interactive)
                  (load-theme 'doom-solarized-light t))

                (quiescent-load-dark-theme)))

  (use-package doom-modeline
      :straight t
      :config (doom-modeline-mode t))
#+END_SRC

There's another thing that you can do about nested blocks: you can
modify nested blocks font lock so that you can tell what block some
code belongs to.  Prism does exactly that.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref prism :lexical t
  (use-package prism
    :straight t
    ;; Based on the readme for prism, adjusted to look closer to the
    ;; original doom theme
    :config (progn
              (defun quiescent-prism-mode ()
                "Enable Prism, only when we're not loading."
                (when (null quiescent-starting-up)
                  (prism-mode 1)))
              (prism-set-colors :num 24
                :desaturations (list 10 20 30) :lightens (list 0 -0.25 -5)
                :colors (list 'font-lock-string-face 'font-lock-keyword-face
                              'font-lock-function-name-face 'font-lock-constant-face
                              'font-lock-type-face))
              ;; Byte compiler can't handle this as a second set of
              ;; hooks for some reason...
              (add-hook 'python-mode-hook #'prism-whitespace-mode)
              (add-hook 'makefile-mode-hook #'prism-whitespace-mode)
              (add-hook 'haskell-mode-hook #'prism-whitespace-mode)
              (add-hook 'yaml-mode-hook #'prism-whitespace-mode))
    :hook (((clojure-mode
             emacs-lisp-mode
             lisp-mode
             c++-mode
             c-mode
             js-mode
             js2-mode
             rjsx-mode
             typescript-mode
             sh-mode
             css-mode
             scala-mode
             java-mode
             ruby-mode
             rust-mode
             racket-mode
             rustic-mode)
            . quiescent-prism-mode)))
#+END_SRC

Line feed is a common feature of lisp code and EMACS outputs from
terminals and compilation buffers.  By default they render as =^L= but
I read about a package which renders them as lines across the screen
as if they are actually breaking the page.  That's pretty darn cool, so
I decided to use the package myself.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref page-break-lines :lexical t
  (use-package page-break-lines
   :straight t
   :config (progn
             (add-to-list 'page-break-lines-modes 'sql-mode)
             (global-page-break-lines-mode 1)))
#+END_SRC

Another cool thing that I actually added and then forgot about is
prettify symbols mode.  It allows for common constructs in various
modes to be swapped out for things which look better when viewing
them.  For instance when editing an Emacs Lisp buffer it might be
convenient to view a lambda as the actual Greek character (that's one
of the defaults which the mode has built in.)

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref prettify :lexical t
  (use-package prog-mode
    :init (progn
            (setq prettify-symbols-unprettify-at-point 'right-edge))
    :config (progn
              (defconst quiescent-prog-mode-symbols '()
                "An alist of substitutions to pretify in prog mode.")
              (defun quiescent-prettify-prog-mode ()
                "Pretify general set of symbols in prog mode."
                (when (null quiescent-starting-up)
                  (dolist (symbol-mapping quiescent-prog-mode-symbols)
                    (push symbol-mapping prettify-symbols-alist))))
              (defun quiescent-activate-pretify-symbols-mode ()
                "Activate `pretify-symbols-mode'."
                (when (null quiescent-starting-up)
                  (prettify-symbols-mode 1)))
              (defun quiescent-pretify-elisp ()
                "Pretify symbols in Emacs Lisp mode."
                (when (null quiescent-starting-up)
                  (progn
                    (push '("pcase-lambda" . 955) prettify-symbols-alist)
                    (push '("defun"        . 402) prettify-symbols-alist)
                    (push '("defvar"       . 957) prettify-symbols-alist)
                    (push '("defconst"     . 986) prettify-symbols-alist))))
              (add-hook 'emacs-lisp-mode-hook #'quiescent-pretify-elisp)
              (add-hook 'prog-mode-hook #'quiescent-prettify-prog-mode))
    :hook (((prog-mode text-mode prog-mode) . quiescent-activate-pretify-symbols-mode)))

  (defun quiescent-indent-region-w/o-prettify-before (&rest _)
    "Indent regions without prettify turned on so that it's not improperly offset."
    (prettify-symbols-mode -1))

  (defun quiescent-indent-region-w/o-prettify-after (&rest _)
    "Turn pretify back on after having indented."
    (prettify-symbols-mode 1))

  (advice-add #'indent-region :before #'quiescent-indent-region-w/o-prettify-before)
  (advice-add #'indent-region :after #'quiescent-indent-region-w/o-prettify-after)
#+END_SRC

I want to get straight down to business when I open EMACS!

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref splash-screen
  (setq inhibit-splash-screen t)
#+END_SRC

** Mb-depth
I'm starting to get into recursive editing, especially with icicles;
which is partially premised on it.  mb-depth gives a visual indication
of the depth of the minibuffer so that you can tell just how deep down
the rabbit hole you've gone.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref mb-depth :lexical t
  (use-package mb-depth
      :straight t)
#+END_SRC

** Agenda Margins
I'm paying a bit more attention to the presentation of my agenda
because I want it to feel less cluttered.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref agenda-margins :lexical t
  (defvar quiescent-org-agenda-visible-width 128
    "The width of the visible portion of the org agenda buffer.")

  (defun quiescent-full-window-width (window)
    "Produce the width of WINDOW including its margins."
    (let ((margins (window-margins window)))
      (+ (window-width window)
         (or (car margins) 0)
         (or (cdr margins) 0))))

  (defun quiescent-setup-agenda-margins (&rest _)
    "Compute the margins for the agenda buffer and make it so."
    (dolist (window (window-list))
      (when (string-equal "*Org Agenda*" (buffer-name (window-buffer window)))
        (let ((margin-width (round (max 0 (/ (- (quiescent-full-window-width window)
                                                quiescent-org-agenda-visible-width) 2)))))
         (set-window-margins window margin-width margin-width)))))

  (defun quiescent-reset-margins (&rest _)
    "Reset the margins on all windows to nil."
    (dolist (window (window-list))
      (unless (string-equal "*Org Agenda*" (buffer-name (window-buffer window)))
        (set-window-margins window 0 0))))

  (advice-add #'split-window :before #'quiescent-reset-margins)
  (advice-add #'split-window :after #'quiescent-setup-agenda-margins)

  (add-hook 'window-configuration-change-hook #'quiescent-setup-agenda-margins)
  (add-hook 'window-size-change-hook #'quiescent-setup-agenda-margins)
  (add-hook 'org-agenda-mode-hook #'quiescent-setup-agenda-margins)
#+end_src

** Xhair
Sometimes it's convenient to be able to see the column and row that
the point is on.  I used to use a package on the EmacsWiki called
~crosshairs.el~, but there's a newer (shinier) package called ~xhair.el~
that I'm using now.

#+begin_src emacs-lisp :tangle no :noweb yes :noweb-ref xhair :lexical t
  (use-package xhair
    :straight t)
#+end_src

* Conclusion
EMACS has become a part of my life.  It's had a profound effect on the
way that I think about doing my work and without it I would be a far
worse typist and programmer altogether.  I credit it with a large part
of my ability to deliver on projects and continue to pick up new
programming languages fast.

It has also shaped my philosophy on how good code should be written.
That is, not by blindly following the suggestions which an IDE makes
to me, but by understanding what I'm writing before I do it and then
using the best tools for fast insertion and navigation to make it a
reality.  This is a hallmark of how I work and I'd like to think that
it's one of the biggest things which sets me aside from other
developers.

#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none :lexical t
  ;;; startup --- My startup configuration -*- lexical-binding: t; -*-
  <<the-appearance-of-emacs>>
  <<modifications-to-support-the-environment>>
  <<programming-modifications-across-the-board>>
  <<modifications-to-specific-programming-languages>>
  <<non-programming-usages>>
  <<writing-natural-language>>
  <<controlling-emacs>>
  <<library-additions-to-emacs>>
#+END_SRC
